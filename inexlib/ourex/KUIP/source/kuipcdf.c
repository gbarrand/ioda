/*
 * This file has been generated by the KUIP compiler.  Do NOT change it!
 *
 * KUIP header: 950303      Generation date: Wed Oct 16 13:33:35 1996
 *
 * Input file: kuipcdf.cdf
 */

#if !defined(F77_LCASE) && !defined(F77_UCASE) && !defined(F77_USCORE)
#  if defined(__EXTENDED__) && !defined(IBM370) && !defined(_IBMR2)
#    define IBM370
#  endif
#  if defined(CRAY) || defined(IBM370) || defined(vms)
#    define F77_UCASE
#  else
#    if ( defined(apollo) || defined(__apollo) ) && defined(APOFTN)
#      define F77_LCASE
#    else
#      define F77_USCORE
#    endif
#  endif
#endif

typedef int     IntFunc();
typedef char*   CharFunc();
typedef char** pCharFunc();
typedef void    SUBROUTINE();
#ifdef IBM370
#  pragma linkage(SUBROUTINE,FORTRAN)
#endif

extern void klnkmenu();
extern void klnkbrcl();
extern void klnkkmcl();
extern void klnkicon();
extern void klnkbutt();

typedef unsigned long KmPixmap; /* Pixmap from <X11/X.h>                   */
 typedef void *KmWidget;         /* Widget from <X11/Intrinsic.h>           */
 typedef void *KmCalldata;       /* XmAnyCallbackStruct from <Motif/Xm.h>   */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BRACT_OPEN = 0,               /*                                         */
   BRACT_ROOT = 1,               /*                                         */
   BRACT_CONT = 2,               /*                                         */
   BRACT_GRAF = 3                /*                                         */
 } BrActTag;                     /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   BrActUpdate    = 0x01,        /* browser window has to be updated ('!')  */
   BrActSeparator = 0x02,        /* put separator in menu ('/')             */
   BrActToggle    = 0x04,        /* register as toggle button               */
   BrActToggleOn  = 0x08,        /* toggle state is on                      */
   BrActSensitive = 0x10         /* button is sensitive                     */
 } BrActFlag;                    /*                                         */
                                 /*                                         */ 

typedef struct _BrAction {      /*                                         */ 
  struct _BrAction *next;       /* link to next action binding             */ 
  BrActFlag   flags;            /*                                         */ 
  char       *text;             /* text line in menu                       */ 
  char       *user_text;        /* user text overriding CDF text (malloced)*/ 
  char       *accel;            /* accelerator                             */ 
  char       *exec;             /* action commands                         */ 
  SUBROUTINE *call_F;           /* action routine                          */ 
  IntFunc    *call_C;           /* action function                         */ 
  BrActTag    tag;              /* for which window the action is defined  */ 
  struct _BrClass *class;       /* pointer to BrClass in case of open menu */
 } BrAction;                     /*                                         */
                                 /*                                         */
 typedef struct _BrClass {       /*                                         */
   struct _BrClass *next;        /* link to next browsable class            */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   SUBROUTINE *scan_km_F;        /* user function scanning the directory    */
   pCharFunc  *scan_km_C;        /* user function scanning the directory    */
   SUBROUTINE *scan_br_F;        /* user function scanning for browsables   */
   pCharFunc  *scan_br_C;        /* user function scanning for browsables   */
   BrAction   *root;             /* list of actions in root window          */
   BrAction   *open;             /* list of actions in open menu            */
 } BrClass;                      /*                                         */
                                 /*                                         */ 

typedef struct _KmIcon {        /*                                         */ 
  struct _KmIcon *next;         /* link to next icon                       */ 
  char       *name;             /* unique identifier name                  */ 
  int         width;            /* width of the pixmap                     */ 
  int         height;           /* height of the pixmap                    */ 
  char       *bitmap;           /* bitmap data                             */ 
  KmPixmap    pix;              /* filled in Motif part                    */ 
  KmPixmap    hi_pix;           /* high lighted pixmap                     */
 } KmIcon;                       /*                                         */
                                 /*                                         */
 typedef struct _KmClass {       /*                                         */
   struct _KmClass *next;        /* link to next object class               */
   int         is_dir;           /* flag if class has is a directory        */
   char       *name;             /* unique identifier name                  */
   char       *title;            /* title for popup menu (maybe NULL)       */
   char       *big_icon;         /* name of the big icon                    */
   KmIcon     *bicon;            /* pointer to the big icon structure       */
   char       *sm_icon;          /* name of the small icon                  */
   KmIcon     *sicon;            /* pointer to the small icon structure     */
   SUBROUTINE *user_icon_F;      /* user function to return icon bitmap     */
   IntFunc    *user_icon_C;      /* user function to return icon bitmap     */
   BrAction   *cont;             /* list of actions in content window       */
   BrAction   *graf;             /* list of actions in graphics window      */
   int         obj_count;        /* number of objects in content window     */
 } KmClass;                      /*                                         */
                                 /*                                         */ 

typedef enum {                  /*                                         */ 
  KmButtSensitive       = 0x00, /* sensitive button                        */ 
  KmButtNonSensitive    = 0x01, /* non-sensitive button ('NS')             */ 
  KmButtToggleSensitive = 0x02, /* toggle-sensitive button ('TS')          */ 
  KmButtSensitivityMask = 0x03, /* mask for sensitivity type               */ 
  KmButtSeparator       = 0x04, /* put separator in menu ('/')             */ 
  KmButtBrowser         = 0x08  /* button is in main browser ('BR')        */
 } KmButtFlag;                   /*                                         */
                                 /*                                         */
 typedef struct _KmButton {      /*                                         */
   struct _KmButton *next;       /* button label or menu item               */
   char       *menu;             /* menu name or NULL for buttons           */
   char       *label;            /* button label or menu item               */
   SUBROUTINE *call_F;           /* callback routine (FORTRAN)              */
   IntFunc    *call_C;           /* callback routine (C)                    */
   char       *action;           /* name of callback routine                */
   char       *mnemo;            /* button mnemonic                         */
   char       *accel;            /* button accelerator                      */
   char       *accel_text;       /* button accelerator text                 */
   KmButtFlag  flags;            /* sensitivity type etc.                   */
   KmWidget    widget;           /* Motif widget ID                         */
 } KmButton;                     /*                                         */
                                 /*                                         */ 

struct {                        /*                                         */ 
  /* indirect calls to avoid linking HIGZ                                  */ 
  IntFunc    *graf_info_C;      /* pass display, open and close (ixmotif)  */ 
  SUBROUTINE *graf_size_F;      /* resize window (IGRSIZ)                  */ 
  SUBROUTINE *graf_pick_F;      /* identifying graphics objects (IGOBJ)    */ 
  SUBROUTINE *graf_attr_F;      /* set attributes (IGSET)                  */ 
  SUBROUTINE *graf_close_F;     /* close workstation (ICLWK)               */ 
  /* optional routines for Motif customization                             */ 
  pCharFunc  *user_FallBk_C;    /* get application fallbacks               */ 
  IntFunc    *user_TopWid_C;    /* pass toplevel widget identifiers        */
 } klnkaddr = {0};                     /*                                         */ 

typedef enum {                  /*                                         */ 
  KmFLAG_FORGET = 0x01,         /* last value is not kept for Motif panels */ 
  KmFLAG_MINUS  = 0x02,         /* -VALUE is not an abbrev for CHOPT=VALUE */ 
  KmFLAG_QUOTE  = 0x04,         /* do not remove quotes                    */ 
  KmFLAG_VARARG = 0x08,         /* append additional args to this param.   */ 
  KmFLAG_CONST  = 0x10,         /* do not allow to assign a value          */ 
  KmFLAG_HIDDEN = 0x20,         /* do not show in menus                    */ 
  KmFLAG_SEPARATE = 0x40        /* treat arguments as separate tokens      */
 } KmParFlag;                    /*                                         */
                                 /*                                         */
 typedef enum {                  /*                                         */
   KmTYPE_CHAR   = 'C',          /* character string                        */
   KmTYPE_FILE   = 'F',          /* file name                               */
   KmTYPE_INT    = 'I',          /* integer                                 */
   KmTYPE_OPTION = 'O',          /* option                                  */
   KmTYPE_REAL   = 'R'           /* real                                    */
 } KmParType;                    /*                                         */
                                 /*                                         */ 

typedef struct {                /* file name                               */ 
  char         *filter_default; /* filter wildcard                         */ 
  char         *filter_current; /* current filter                          */
 } KmParFile;                    /*                                         */
                                 /*                                         */
 typedef struct {                /*                                         */
   char         *range_lower;    /* lower value of range                    */
   char         *range_upper;    /* upper value of range                    */
   char         *slider_lower;   /* lower limit for slider                  */
   char         *slider_upper;   /* upper limit for slider                  */
   int           decimals;       /* number of decimals used for slider      */
 } KmParInt;                     /*                                         */
                                 /*                                         */
 typedef struct {                /* option                                  */
   char        **text;           /* explanations (parallel to range_value)  */
   int          *mutex;          /* mutex group to which text belongs       */
   int          *radio;          /* radio group to which text belongs       */
 } KmParOption;                  /*                                         */
                                 /*                                         */ 

typedef KmParInt KmParReal;     /* real and int have the same fields       */ 
                                /*                                         */
 typedef struct {                /*                                         */
   char         *name;           /* parameter name                          */
   int           abbrev;         /* minimum length that name is recognized  */
   char         *prompt;         /* prompt string                           */
   char         *dfault;         /* default value                           */
   char         *last;           /* last value for Motif panel (malloced)   */
   int           width;          /* width of input field                    */
   int           range_count;    /* number of items in range_value          */
   char        **range_value;    /* list of allowed values                  */
   int           select_count;   /* number of items in select_count         */
   char        **select_value;   /* list of values for selection box        */
   KmParFlag     flags;          /* special flags                           */
   KmParType     type;           /* parameter type                          */
   void        *ptype;           /* structure pointer selected by type      */
 } KmParameter;                  /*                                         */
                                 /*                                         */ 

typedef struct _KmCommand {     /*                                         */ 
  struct _KmCommand *next;      /* link to next command                    */ 
  char         *path;           /* command path                            */ 
  char         *name;           /* command name                            */ 
  int           hidden;         /* flag if command is invisible            */ 
  int           level;          /* depth of submenus                       */ 
  int           total;          /* total number of parameters              */ 
  int           mandatory;      /* number of mandatory parameters          */ 
  KmParameter **par;            /* list of total parameter descriptions    */ 
  int           list_par;       /* index+1 of parameter taking a list      */ 
  int           xcount;         /* count number of action calls            */ 
  SUBROUTINE   *action_F;       /* action routine                          */ 
  IntFunc      *action_C;       /* action routine                          */ 
  SUBROUTINE   *user_help_F;    /* user help routine                       */ 
  pCharFunc    *user_help_C;    /* user help routine                       */ 
  int          nguidance;       /* number of lines in guidance text        */ 
  char        **guidance;       /* help text                               */ 
  int          nkeyword;        /* number of lines for keywords            */ 
  char        **keyword;        /* list of keywords                        */ 
  int          nhlink;          /* number of lines for links               */ 
  char        **hlink;          /* list of links                           */ 
  int           argc;           /* number of arguments entered             */ 
  char        **argv;           /* argc argument values                    */ 
  char         *argline;        /* argument line as entered                */ 
  int          *argoffs;        /* argc offsets into argline for KUGETE    */
 } KmCommand;                    /*                                         */
                                 /*                                         */ 

typedef struct _KmMenu {        /*                                         */ 
  struct _KmMenu *next;         /* link to next menu                       */ 
  struct _KmMenu *down;         /* link to submenu                         */ 
  char         *path;           /* path of parent menu                     */ 
  char         *name;           /* menu name                               */ 
  int           level;          /* depth of submenus                       */ 
  KmCommand    *cmds;           /* link to first command                   */ 
  int          nguidance;       /* number of lines in guidance text        */ 
  char        **guidance;       /* help text                               */ 
  int          nkeyword;        /* number of lines for keywords            */ 
  char        **keyword;        /* list of keywords                        */ 
  int          nhlink;          /* number of lines for links               */ 
  char        **hlink;          /* list of links                           */
 } KmMenu;                       /*                                         */
                                 /*                                         */
 extern void klnkbrcl();         /*                                         */
 extern void klnkicon();         /*                                         */
 extern void klnkkmcl();         /*                                         */
 extern void klnkmenu();         /*                                         */
                                 /*                                         */ 

#ifdef F77_LCASE
#  define kuidf1_ kuidf1
#  define kxunit_ kxunit
#endif

#ifdef F77_UCASE
#  define kuidf1_ KUIDF1
#  define kxunit_ KXUNIT
#endif

#ifdef IBM370
#  pragma linkage(KUIDF1,FORTRAN)
#  pragma linkage(KXUNIT,FORTRAN)
#endif

extern void kuidf1_();
extern void kxunit_();

extern char **kxfunclist();
extern int kxexit();
extern int kxidle();
extern int kxwait();
extern int kxshell();
extern int kxfmessage();
extern int kxmessage();
extern int kxlast();
extern int kxpsview();
extern int kxprint();
extern int kxedit();
extern int kxmanual();
extern int kxusage();
extern int kxhelp();
extern int kxfind();

void kuidf1_()
{

static char *_KUIP_FUNCTIONS_guidance[] = {
 "List of all KUIP System Functions.", "",
 "       *** KUIP System Functions ***", "",
 "The function name (and arguments) is literally replaced,",
 "at run-time, by its current value.",
 "At present, the following functions are available:",
 " $DATE  .......................  Current date in format DD/MM/YY",
 " $TIME  .......................  Current time in format HH.MM.SS",
 " $CPTIME  .....................  CP time elapsed since last call (in sec)",
 " $RTIME  ......................  Real time elapsed since last call (in\
 sec)", " $VDIM(VNAME,IDIM)  ...........  Physical length of vector VNAME",
 "                                 on dimension IDIM (1..3)",
 " $VLEN(VNAME,IDIM)  ...........  As above, but for the logical length",
 "                                 (i.e. stripping trailing zeroes)",
 " $NUMVEC  .....................  Current number of vectors",
 " $VEXIST(VNAME)  ..............  Index of vector VNAME",
 "                                 (1..$NUMVEC or 0 if VNAME does not exist)",
 " $SUBSTRING(STRING,IX,NCH)  ...  STRING(IX:IX+NCH-1)",
 " $UPPER(STRING)  ..............  STRING changed to upper case",
 " $LOWER(STRING)  ..............  STRING changed to lower case",
 " $LEN(STRING)  ................  Length of STRING",
 " $INDEX(STR1,STR2)  ...........  Position of first occurrence of STR2 in\
 STR1", " $WORDS(STRING,SEP)  ..........  Number of words separated by SEP",
 " $WORD(STRING,K,N,SEP)  .......  Extract N words starting at word K",
 " $QUOTE(STRING)  ..............  Add quotes around STRING",
 " $UNQUOTE(STRING)  ............  Remove quotes around STRING",
 " $EXEC('macro args')  .........  EXITM value of EXEC call",
 " $DEFINED('var_name')  ........  List of defined macro variables",
 " $EVAL(Expression)  ...........  Result of the Expression computed by KUIP",
 " $SIGMA(Expression)  ..........  Result of the Expression computed by\
 SIGMA",
 " $RSIGMA(Expression) ..........  As above but a decimal point is added to",
 "                                 integer results",
 " $FORMAT(number,format)  ......  Format a number according to a Fortran",
 "                                 format string, e.g.",
 "                                 $FORMAT(1.5,F5.2) ==> ' 1.50'",
 "                                 $FORMAT(123,I5.5) ==> '00123'",
 " $ARGS  .......................  Command line at program invocation",
 " $KEYNUM  .....................  Address of latest clicked key in style GP",
 " $KEYVAL  .....................  Value of latest clicked key in style GP",
 " $LAST  .......................  Latest command line executed",
 " $ANUM  .......................  Number of aliases",
 " $ANAM(I)  ....................  Name of I-th alias",
 " $AVAL(I)  ....................  Value of I-th alias",
 " $STYLE  ......................  Current style as defined by SET/STYLE",
 " $OS  .........................  Operating system name, e.g. UNIX or VMS",
 " $MACHINE  ....................  Hardware or Unix brand, e.g. VAX or HPUX",
 " $PID  ........................  Process ID",
 " $IQUEST(I)  ..................  Value of IQUEST(I) status vector",
 " $ENV(var)  ...................  Value of environment variable",
 " $FEXIST(file)  ...............  1 if file exists or 0 otherwise",
 " $SHELL(cmd,N)  ...............  N'th line of shell command output (Unix\
 only)",
 " $SHELL(cmd,sep)  .............  Shell output with newlines replaced by\
 sep", " $SHELL(cmd)  .................  Same as $SHELL(cmd,' ')" };
static char *_KUIP_FUNCTIONS_keyword[] = { "SYSTEM", "DATE", "TIME",
 "MACHINE", "SHELL", "VDIM", "VLEN", "dimension", "length", "VECTOR",
 "STRING", "EXIST", "UPPER", "LOWER", "INDEX", "FORMAT", "SIGMA" };
static KmCommand _KUIP_FUNCTIONS = {  (KmCommand*)0, "/KUIP/FUNCTIONS",
 "FUNCTIONS", 0, 1, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, kxfunclist, 54, _KUIP_FUNCTIONS_guidance, 17,
 _KUIP_FUNCTIONS_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_QUIT_guidance[] = { "End of the interactive session." };
static KmCommand _KUIP_QUIT = { &_KUIP_FUNCTIONS, "/KUIP/QUIT", "QUIT", 0, 1,
 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, kxexit, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _KUIP_QUIT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_KUIP_EXIT_guidance[] = { "End of the interactive session." };
static KmCommand _KUIP_EXIT = { &_KUIP_QUIT, "/KUIP/EXIT", "EXIT", 0, 1, 0, 0,
 (KmParameter**)0, 0, 0, (SUBROUTINE*)0, kxexit, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _KUIP_EXIT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_KUIP_UNITS_guidance[] = {
 "List all Input/Output logical units currently open.",
 "The files attached to them are also shown." };
static char *_KUIP_UNITS_keyword[] = { "file" };
static KmCommand _KUIP_UNITS = { &_KUIP_EXIT, "/KUIP/UNITS", "UNITS", 0, 1, 0,
 0, (KmParameter**)0, 0, 0, kxunit_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _KUIP_UNITS_guidance, 1, _KUIP_UNITS_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _KUIP_IDLE_SEC_type = { "0", (char*)0, "0", (char*)0, 0 };
static KmParameter _KUIP_IDLE_SEC = { "SEC", 3, "Number of seconds", (char*)0,
 (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_KUIP_IDLE_SEC_type };
static KmParameter _KUIP_IDLE_STRING = { "STRING", 6, "Command string", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_IDLE_parameters[] = { &_KUIP_IDLE_SEC,
 &_KUIP_IDLE_STRING };
static char *_KUIP_IDLE_guidance[] = {
 "Execute a command if program is idle.",
 "The command string is executed if there was no keyboard activity",
 "during SEC seconds." };
static char *_KUIP_IDLE_keyword[] = { "keyboard", "time", "timing" };
static KmCommand _KUIP_IDLE = { &_KUIP_UNITS, "/KUIP/IDLE", "IDLE", 0, 1, 2,
 1, _KUIP_IDLE_parameters, 0, 0, (SUBROUTINE*)0, kxidle, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _KUIP_IDLE_guidance, 3, _KUIP_IDLE_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_WAIT_STRING = { "STRING", 6, "Message string", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParReal   _KUIP_WAIT_SEC_type = { "0", (char*)0, "0", (char*)0, 0 };
static KmParameter _KUIP_WAIT_SEC = { "SEC", 3, "Number of seconds", "0",
 (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_KUIP_WAIT_SEC_type };
static KmParameter *_KUIP_WAIT_parameters[] = { &_KUIP_WAIT_STRING,
 &_KUIP_WAIT_SEC };
static char *_KUIP_WAIT_guidance[] = { "Make a pause (e.g. inside a macro).",
 "Wait a given number of seconds (if SEC.GT.0)",
 "or just until <CR> is entered (if SEC.EQ.0).",
 "A message string is also written on the terminal before waiting." };
static char *_KUIP_WAIT_keyword[] = { "pause", "time", "timing" };
static KmCommand _KUIP_WAIT = { &_KUIP_IDLE, "/KUIP/WAIT", "WAIT", 0, 1, 2, 0,
 _KUIP_WAIT_parameters, 0, 0, (SUBROUTINE*)0, kxwait, (SUBROUTINE*)0,
 (pCharFunc*)0, 4, _KUIP_WAIT_guidance, 3, _KUIP_WAIT_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_SHELL_CMD = { "CMD", 3, "Shell command string", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_SHELL_parameters[] = { &_KUIP_SHELL_CMD };
static char *_KUIP_SHELL_guidance[] = {
 "Execute a command of the host operating system.",
 "The command string is passed to the command processor defined by\
 HOST_SHELL.", "If CMD=' ' the shell is spawned as interactive subprocess.",
 "To return from the shell enter 'RETURN' (the full word, not just <CR>)",
 "or 'exit' (depending on the operation system)." };
static char *_KUIP_SHELL_keyword[] = { "SYSTEM" };
static KmCommand _KUIP_SHELL = { &_KUIP_WAIT, "/KUIP/SHELL", "SHELL", 0, 1, 1,
 0, _KUIP_SHELL_parameters, 0, 0, (SUBROUTINE*)0, kxshell, (SUBROUTINE*)0,
 (pCharFunc*)0, 5, _KUIP_SHELL_guidance, 1, _KUIP_SHELL_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_FMESSAGE_STRING = { "STRING", 6, "Message string",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)64, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter _KUIP_FMESSAGE_OUTPUT = { "OUTPUT", 6, "Output file name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_FMESSAGE_parameters[] = { &_KUIP_FMESSAGE_STRING,
 &_KUIP_FMESSAGE_OUTPUT };
static char *_KUIP_FMESSAGE_guidance[] = {
 "Write a message string on OUTPUT file name.",
 "OUTPUT file is opened in \"append\" mode (open for writing at end of",
 "file, or create for writing).",
 "If OUTPUT=' ' the text is written to the terminal.",
 "If 'Message string' contains several words separated by one or more",
 "spaces the string must be surrounded by single quotes." };
static char *_KUIP_FMESSAGE_keyword[] = { "string", "macro", "file", "put",
 "puts" };
static KmCommand _KUIP_FMESSAGE = { &_KUIP_SHELL, "/KUIP/FMESSAGE",
 "FMESSAGE", 0, 1, 2, 0, _KUIP_FMESSAGE_parameters, 0, 0, (SUBROUTINE*)0,
 kxfmessage, (SUBROUTINE*)0, (pCharFunc*)0, 6, _KUIP_FMESSAGE_guidance, 5,
 _KUIP_FMESSAGE_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_MESSAGE_STRING = { "STRING", 6, "Message string",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)64, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_MESSAGE_parameters[] = { &_KUIP_MESSAGE_STRING };
static char *_KUIP_MESSAGE_guidance[] = {
 "Write a message string on the terminal.",
 "A useful command inside a macro.",
 "Several message strings can be given in the same command line,",
 "each of them separated by one or more spaces",
 "(the usual parameter separator);",
 "therefore multiple blanks will be dropped", "and only one will be kept.",
 "If multiple blanks should not be dropped,",
 "the string must be surrounded by single quotes." };
static char *_KUIP_MESSAGE_keyword[] = { "string", "macro" };
static KmCommand _KUIP_MESSAGE = { &_KUIP_FMESSAGE, "/KUIP/MESSAGE",
 "MESSAGE", 0, 1, 1, 0, _KUIP_MESSAGE_parameters, 0, 0, (SUBROUTINE*)0,
 kxmessage, (SUBROUTINE*)0, (pCharFunc*)0, 9, _KUIP_MESSAGE_guidance, 2,
 _KUIP_MESSAGE_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParInt    _KUIP_LAST_N_type = { "-99", (char*)0, "-99", (char*)0, 0 };
static KmParameter _KUIP_LAST_N = { "N", 1, "N last commands to be saved",
 "-99", (char*)0, 8, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_INT,
 &_KUIP_LAST_N_type };
static KmParameter _KUIP_LAST_FNAME = { "FNAME", 5, "File name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_LAST_parameters[] = { &_KUIP_LAST_N,
 &_KUIP_LAST_FNAME };
static char *_KUIP_LAST_guidance[] = {
 "Perform various operations with the history file.", "",
 "If FNAME is not specified, the current history file is assumed by default",
 "(the startup history file name is LAST.KUMAC).",
 "To change the history file the command LAST 0 NEW-FNAME must be entered.",
 "", "If N.EQ.-99 (default case) the default host editor is called",
 "to edit the current history file, containing all the commands of the\
 session.", "", "If N.LT.0 the last -N commands are printed on the screen.",
 "On MVS this allows to edit and resubmit commands.",
 "On workstations this allows to resubmit blocks of commands by mouse-driven",
 "cut-and-paste operations.", "",
 "If N.EQ.0 the history file FNAME is rewound and set as the current one",
 "(the command LAST 0 FNAME itself is not recorded).", "",
 "If N.GT.0 the last N commands of the session are saved in the",
 "current history file.", "", "See also the command RECORDING." };
static char *_KUIP_LAST_keyword[] = { "history", "file", "RECORDING", "RECORD"
 };
static KmCommand _KUIP_LAST = { &_KUIP_MESSAGE, "/KUIP/LAST", "LAST", 0, 1, 2,
 0, _KUIP_LAST_parameters, 0, 0, (SUBROUTINE*)0, kxlast, (SUBROUTINE*)0,
 (pCharFunc*)0, 21, _KUIP_LAST_guidance, 4, _KUIP_LAST_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_PSVIEW_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_PSVIEW_parameters[] = { &_KUIP_PSVIEW_FNAME };
static char *_KUIP_PSVIEW_guidance[] = {
 "Invoke the PostScript viewer on the file.",
 "The command HOST_PSVIEWER can be used to define the PostScript viewer.", "",
 "If FNAME does not contain an extension the default filetype '.PS'",
 "is supplied." };
static char *_KUIP_PSVIEW_keyword[] = { "PostScript", "display", "viewer" };
static KmCommand _KUIP_PSVIEW = { &_KUIP_LAST, "/KUIP/PSVIEW", "PSVIEW", 0, 1,
 1, 1, _KUIP_PSVIEW_parameters, 0, 0, (SUBROUTINE*)0, kxpsview,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _KUIP_PSVIEW_guidance, 3,
 _KUIP_PSVIEW_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_PRINT_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_PRINT_parameters[] = { &_KUIP_PRINT_FNAME };
static char *_KUIP_PRINT_guidance[] = { "Send a file to the printer.",
 "The command HOST_PRINT can be used to define the host command for",
 "printing the file depending on it file extension." };
static char *_KUIP_PRINT_keyword[] = { "printer" };
static KmCommand _KUIP_PRINT = { &_KUIP_PSVIEW, "/KUIP/PRINT", "PRINT", 0, 1,
 1, 1, _KUIP_PRINT_parameters, 0, 0, (SUBROUTINE*)0, kxprint, (SUBROUTINE*)0,
 (pCharFunc*)0, 3, _KUIP_PRINT_guidance, 1, _KUIP_PRINT_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_EDIT_FNAME = { "FNAME", 5, "File name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_EDIT_parameters[] = { &_KUIP_EDIT_FNAME };
static char *_KUIP_EDIT_guidance[] = { "Invoke the editor on the file.",
 "The command HOST_EDITOR can be used to define the editor.", "",
 "If FNAME does not contain an extension the default filetype '.KUMAC'",
 "is supplied.",
 "The search path defined by the command DEFAULTS is used to find an",
 "already existing file.",
 "If the file does not exist it is created with the given name." };
static char *_KUIP_EDIT_keyword[] = { "EDITOR", "file" };
static KmCommand _KUIP_EDIT = { &_KUIP_PRINT, "/KUIP/EDIT", "EDIT", 0, 1, 1,
 1, _KUIP_EDIT_parameters, 0, 0, (SUBROUTINE*)0, kxedit, (SUBROUTINE*)0,
 (pCharFunc*)0, 8, _KUIP_EDIT_guidance, 2, _KUIP_EDIT_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_MANUAL_ITEM = { "ITEM", 4, "Command or menu path",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _KUIP_MANUAL_OUTPUT = { "OUTPUT", 6, "Output file name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static char *_KUIP_MANUAL_OPTION_range[] = { "", "LATEX", "TEX" };
static char *_KUIP_MANUAL_OPTION_text[] = { "plain text : plain text format",
 "LaTeX format (encapsulated)", "LaTeX format (without header)" };
static KmParOption _KUIP_MANUAL_OPTION_type = { _KUIP_MANUAL_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _KUIP_MANUAL_OPTION = { "OPTION", 6,
 "Text formatting system", " ", (char*)0, 8, 3, _KUIP_MANUAL_OPTION_range, 3,
 _KUIP_MANUAL_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_MANUAL_OPTION_type };
static KmParameter *_KUIP_MANUAL_parameters[] = { &_KUIP_MANUAL_ITEM,
 &_KUIP_MANUAL_OUTPUT, &_KUIP_MANUAL_OPTION };
static char *_KUIP_MANUAL_guidance[] = {
 "Write on a file the text formatted help of a command.",
 "If ITEM is a menu path the help for all commands linked to that menu",
 "is written.",
 "If ITEM='/' the help for the complete command tree is written.",
 "If OUTPUT=' ' the text is written to the terminal.", "",
 "The output file produced with option LATEX can be processed directly by\
 LaTeX,",
 "i.e. it contains a standard header defining the meta commands used for",
 "formatting the document body.",
 "With option TEX only the document body is written into the output file",
 "which can be included by a driver file containing customized definitions",
 "of the standard meta commands.", "Example:", " MANUAL / MAN.TEX LATEX",
 "will produce the file MAN.TEX containg the documentation of all",
 "available commands in LaTeX format." };
static char *_KUIP_MANUAL_keyword[] = { "LATEX", "TEX", "format", "HELP",
 "command" };
static KmCommand _KUIP_MANUAL = { &_KUIP_EDIT, "/KUIP/MANUAL", "MANUAL", 0, 1,
 3, 1, _KUIP_MANUAL_parameters, 0, 0, (SUBROUTINE*)0, kxmanual,
 (SUBROUTINE*)0, (pCharFunc*)0, 16, _KUIP_MANUAL_guidance, 5,
 _KUIP_MANUAL_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_USAGE_ITEM = { "ITEM", 4, "Command name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_USAGE_parameters[] = { &_KUIP_USAGE_ITEM };
static char *_KUIP_USAGE_guidance[] = { "Give the syntax of a command.",
 "If ITEM='/' the syntax of all commands is given." };
static char *_KUIP_USAGE_keyword[] = { "help", "syntax", "command" };
static KmCommand _KUIP_USAGE = { &_KUIP_MANUAL, "/KUIP/USAGE", "USAGE", 0, 1,
 1, 1, _KUIP_USAGE_parameters, 0, 0, (SUBROUTINE*)0, kxusage, (SUBROUTINE*)0,
 (pCharFunc*)0, 2, _KUIP_USAGE_guidance, 3, _KUIP_USAGE_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_CHELP_ITEM = { "ITEM", 4, "Command or menu path",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static char *_KUIP_CHELP_OPTION_range[] = { "EDIT", "E", "NOEDIT", "N" };
static char *_KUIP_CHELP_OPTION_text[] = {
 "The help text is written to a file and the editor is invoked,",
 "Same as 'EDIT'.", "The help text is output on the terminal output.",
 "Same as 'NOEDIT'" };
static KmParOption _KUIP_CHELP_OPTION_type = { _KUIP_CHELP_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _KUIP_CHELP_OPTION = { "OPTION", 6, "View mode", "N",
 (char*)0, 8, 4, _KUIP_CHELP_OPTION_range, 4, _KUIP_CHELP_OPTION_range,
 (KmParFlag)0, KmTYPE_OPTION, &_KUIP_CHELP_OPTION_type };
static KmParameter *_KUIP_CHELP_parameters[] = { &_KUIP_CHELP_ITEM,
 &_KUIP_CHELP_OPTION };
static char *_KUIP_CHELP_guidance[] = {
 "Find help information only on valid command name or menu path.", "",
 "A more general help facility, associated to keywords, is given by",
 "the command HELP.", "",
 "If ITEM is a command its full explanation is given:",
 "syntax (as given by the command USAGE), functionality,",
 "list of parameters with their attributes (prompt, type, default, range,\
 etc.).", "If ITEM='/' the help for all commands is given.", "",
 "If CHELP is entered without parameters or ITEM is a submenu,",
 "the dialogue style is switched",
 "to 'AN', guiding the user in traversing the tree command structure.", "",
 "'CHELP -EDIT' (or just 'CHELP -E') switches to edit mode:",
 "instead of writing the help text to the terminal output,",
 "it is written into a temporary file and the pager or editor defined",
 "by the command HOST_PAGER is invoked.",
 "(On Unix workstations the pager can be defined to display the help text",
 "asynchrously in a separated window.)",
 "'CHELP -NOEDIT' (or just 'CHELP -N') switches back to standard mode.",
 "The startup value is system dependent." };
static KmCommand _KUIP_CHELP = { &_KUIP_USAGE, "/KUIP/CHELP", "CHELP", 0, 1,
 2, 0, _KUIP_CHELP_parameters, 0, 0, (SUBROUTINE*)0, kxhelp, (SUBROUTINE*)0,
 (pCharFunc*)0, 22, _KUIP_CHELP_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_HELP_ITEM = { "ITEM", 4,
 "Command or menu name or keyword(s)", " ", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_KUIP_HELP_OPTION_range[] = { "EDIT", "NOEDIT", "KEYWORD", "E",
 "N", "K" };
static char *_KUIP_HELP_OPTION_text[] = {
 "The help text is written to a file and the editor is invoked,",
 "The help text is output on the terminal output.",
 "give access to all commands associated to that keyword(s).",
 "Same as 'EDIT'.", "Same as 'NOEDIT'", "Same as 'KEYWORD'" };
static KmParOption _KUIP_HELP_OPTION_type = { _KUIP_HELP_OPTION_text, (int*)0,
 (int*)0 };
static KmParameter _KUIP_HELP_OPTION = { "OPTION", 6, "Option", "N", (char*)0,
 8, 6, _KUIP_HELP_OPTION_range, 6, _KUIP_HELP_OPTION_range, (KmParFlag)0,
 KmTYPE_OPTION, &_KUIP_HELP_OPTION_type };
static KmParameter *_KUIP_HELP_parameters[] = { &_KUIP_HELP_ITEM,
 &_KUIP_HELP_OPTION };
static char *_KUIP_HELP_guidance[] = {
 "Find help information by command name, menu name or keywords.", "",
 "If ITEM is a valid command name (and there is only one such command)",
 "then full explanation on that command is provided: syntax (as given by",
 "the command USAGE), functionality, list of parameters with their\
 attributes.",
 "If ITEM also corresponds to other commands associated to it with a\
 \"keyword\"",
 "then a \"See also\" message, followed by the names of these commands",
 "is given.", "",
 "If ITEM is a menu (or a submenu) a dialogue is guiding the user in\
 traversing",
 "the tree command structure for getting full explanation on a specific",
 "command from that tree.", "",
 "If HELP is entered without parameters, the search start from the top level",
 "menu and the user is guided in traversing the complete tree command\
 structure.", "",
 "'HELP -KEYWORD' (or 'HELP -K') followed by one or more keywords causes\
 HELP",
 "to give access to all commands associated to that (list of) keyword(s).",
 "If the keyword corresponds to a valid command or (sub)menu name all",
 "corresponding commands are accessible. This option is especially useful",
 "when you do not know the exact name of a valid command or menu and you can",
 "only describe it by its functionality (e.g. 'HELP -KEYWORD POSTSCRIPT').",
 "",
 "N.B. If ITEM does not correspond to any valid command or menu name then",
 "the option `-KEYWORD' is automatically invoked.", "",
 "'HELP -EDIT' (or just 'CHELP -E') switches to edit mode: instead of\
 writing",
 "the help text to the terminal output, it is written into a temporary file",
 "and the pager or editor defined by the command HOST_PAGER is invoked.",
 "(On Unix workstations the pager can be defined to display the help text",
 "asynchrously in a separated window.)",
 "'CHELP -NOEDIT' (or just 'CHELP -N') switches back to standard mode.",
 "The startup value is system dependent." };
static char *_KUIP_HELP_keyword[] = { "FIND", "keyword", "search" };
static KmCommand _KUIP_HELP = { &_KUIP_CHELP, "/KUIP/HELP", "HELP", 0, 1, 2,
 0, _KUIP_HELP_parameters, 0, 0, (SUBROUTINE*)0, kxfind, (SUBROUTINE*)0,
 (pCharFunc*)0, 33, _KUIP_HELP_guidance, 3, _KUIP_HELP_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_guidance[] = { "Command Processor commands." };
static KmMenu _KUIP = {  (KmMenu*)0,  (KmMenu*)0, "/KUIP", "KUIP", 1,
 &_KUIP_HELP, 1, _KUIP_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_KUIP, 950303 );
}


#ifdef F77_LCASE
#  define kuidf2_ kuidf2
#endif

#ifdef F77_UCASE
#  define kuidf2_ KUIDF2
#endif

#ifdef IBM370
#  pragma linkage(KUIDF2,FORTRAN)
#endif

extern void kuidf2_();

extern int kxatranslation();
extern int kxadelete();
extern int kxalist();
extern int kxacreate();
extern int kxlcdir();
extern int kxfilecase();
extern int kxdollar();
extern int kxvisibility();
extern int kxrecallstyle();
extern int kxhostshell();
extern int kxhostpsviewer();
extern int kxhostprinter();
extern int kxhostpager();
extern int kxhosteditor();
extern int kxrecording();
extern int kxcolumns();
extern int kxbreak();
extern int kxprompt();
extern int kxtiming();
extern int kxroot();
extern int kxapplication();
extern int kxcommand();
extern int kxnewpan();
extern int kxpanel();
extern int kxstyle();

void kuidf2_()
{

static char *_KUIP_ALIAS_TRANSLATION_OPTION_range[] = { "?", "ON", "OFF" };
static char *_KUIP_ALIAS_TRANSLATION_OPTION_text[] = { "show current setting",
 "switch alias translation ON", "switch alias translation OFF" };
static KmParOption _KUIP_ALIAS_TRANSLATION_OPTION_type = {
 _KUIP_ALIAS_TRANSLATION_OPTION_text, (int*)0, (int*)0 };
static KmParameter _KUIP_ALIAS_TRANSLATION_OPTION = { "OPTION", 6, "Option",
 "ON", (char*)0, 8, 3, _KUIP_ALIAS_TRANSLATION_OPTION_range, 3,
 _KUIP_ALIAS_TRANSLATION_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_ALIAS_TRANSLATION_OPTION_type };
static KmParameter *_KUIP_ALIAS_TRANSLATION_parameters[] = {
 &_KUIP_ALIAS_TRANSLATION_OPTION };
static char *_KUIP_ALIAS_TRANSLATION_guidance[] = {
 "Switch ON/OFF the alias translation.",
 "If OFF, alias definitions are not used in parsing the command lines.",
 "It is automatically switched ON when an alias is created.",
 "If OPTION='?' the current value is shown.", "The startup value is OFF." };
static KmCommand _KUIP_ALIAS_TRANSLATION = {  (KmCommand*)0,
 "/KUIP/ALIAS/TRANSLATION", "TRANSLATION", 0, 2, 1, 0,
 _KUIP_ALIAS_TRANSLATION_parameters, 0, 0, (SUBROUTINE*)0, kxatranslation,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _KUIP_ALIAS_TRANSLATION_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_ALIAS_DELETE_NAME = { "NAME", 4,
 "Alias name wildcard", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_ALIAS_DELETE_parameters[] = {
 &_KUIP_ALIAS_DELETE_NAME };
static char *_KUIP_ALIAS_DELETE_guidance[] = {
 "Delete the definition of aliases matching the wildcard.",
 "NAME='*' deletes all aliases." };
static KmCommand _KUIP_ALIAS_DELETE = { &_KUIP_ALIAS_TRANSLATION,
 "/KUIP/ALIAS/DELETE", "DELETE", 0, 2, 1, 1, _KUIP_ALIAS_DELETE_parameters, 1,
 0, (SUBROUTINE*)0, kxadelete, (SUBROUTINE*)0, (pCharFunc*)0, 2,
 _KUIP_ALIAS_DELETE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _KUIP_ALIAS_LIST_NAME = { "NAME", 4, "Alias name wildcard",
 "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_ALIAS_LIST_parameters[] = { &_KUIP_ALIAS_LIST_NAME };
static char *_KUIP_ALIAS_LIST_guidance[] = {
 "List all aliases matching the wildcard (names and values)." };
static KmCommand _KUIP_ALIAS_LIST = { &_KUIP_ALIAS_DELETE, "/KUIP/ALIAS/LIST",
 "LIST", 0, 2, 1, 0, _KUIP_ALIAS_LIST_parameters, 0, 0, (SUBROUTINE*)0,
 kxalist, (SUBROUTINE*)0, (pCharFunc*)0, 1, _KUIP_ALIAS_LIST_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_ALIAS_CREATE_NAME = { "NAME", 4, "Alias name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _KUIP_ALIAS_CREATE_VALUE = { "VALUE", 5, "Alias value",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_KUIP_ALIAS_CREATE_CHOPT_range[] = { "A", "C", "N" };
static char *_KUIP_ALIAS_CREATE_CHOPT_text[] = { "create an Argument alias",
 "create a Command alias", "No alias expansion of value" };
static KmParOption _KUIP_ALIAS_CREATE_CHOPT_type = {
 _KUIP_ALIAS_CREATE_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _KUIP_ALIAS_CREATE_CHOPT = { "CHOPT", 5, "Option", "A",
 (char*)0, 8, 3, _KUIP_ALIAS_CREATE_CHOPT_range, 3,
 _KUIP_ALIAS_CREATE_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_ALIAS_CREATE_CHOPT_type };
static KmParameter *_KUIP_ALIAS_CREATE_parameters[] = {
 &_KUIP_ALIAS_CREATE_NAME, &_KUIP_ALIAS_CREATE_VALUE,
 &_KUIP_ALIAS_CREATE_CHOPT };
static char *_KUIP_ALIAS_CREATE_guidance[] = {
 "Create an alias NAME which should be substituted by VALUE.",
 "An alias name is a sequence of letters and digits starting with a letter.",
 "The underscores ('_'), the at-sign ('@') and the dollar-sign ('$')",
 "count as letters.", "", "There are two types of aliases:",
 "Command aliases are recognized only if they occur in the command position,",
 "i.e. as the first token on the line.",
 "Argument aliases are recognized anywhere on the command line",
 "(except inside quoted strings)",
 "if they are surrounded by one of the following separators:",
 " blank  /  ,  =  :  .  %  '  (  )", "",
 "Also switch ON the alias translation, i.e. ALIAS/TRANSLATION ON.",
 "If CHOPT='C' then the alias is a command alias, i.e. an alias that",
 "will only be translated when it is the first token on a command line.",
 "Example:", " Alias/Create GG Graph/Struct/Scratch",
 " Alias/Create FF File1/Name1/Name2", " GG FF/ID", "is equivalent to",
 " Graph/Struct/Scratch File1/Name1/Name2/ID", "", " Alias/Create LS DIR C",
 "is equivalent to", " DIR",
 "only when LS is the first token on a command line.",
 "In the following case LS will not be translated", " SHELL LS", "",
 "Aliases occuring inside an value are expanded indepedent whether the value",
 "is enclosed by quotes.",
 "The option -N allows to suppress this implicit alias expansion." };
static KmCommand _KUIP_ALIAS_CREATE = { &_KUIP_ALIAS_LIST,
 "/KUIP/ALIAS/CREATE", "CREATE", 0, 2, 3, 2, _KUIP_ALIAS_CREATE_parameters, 0,
 0, (SUBROUTINE*)0, kxacreate, (SUBROUTINE*)0, (pCharFunc*)0, 33,
 _KUIP_ALIAS_CREATE_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static KmParameter _KUIP_SET_SHOW_LCDIR_DIRECTORY = { "DIRECTORY", 3,
 "Directory name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_LCDIR_parameters[] = {
 &_KUIP_SET_SHOW_LCDIR_DIRECTORY };
static char *_KUIP_SET_SHOW_LCDIR_guidance[] = {
 "Set or show the local working directory.", "",
 "The current working directory is set to the given path name or the",
 "current directory is shown.", "",
 "To show the current directory used LCDIR without argument.",
 "'LCDIR ~' switches to the home directory.",
 "'LCDIR .' switches back to the working directory at the time",
 "the program was started." };
static char *_KUIP_SET_SHOW_LCDIR_keyword[] = { "Directory", "dir" };
static KmCommand _KUIP_SET_SHOW_LCDIR = {  (KmCommand*)0,
 "/KUIP/SET_SHOW/LCDIR", "LCDIR", 0, 2, 1, 0, _KUIP_SET_SHOW_LCDIR_parameters,
 0, 0, (SUBROUTINE*)0, kxlcdir, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _KUIP_SET_SHOW_LCDIR_guidance, 2, _KUIP_SET_SHOW_LCDIR_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_SET_SHOW_FILECASE_OPTION_range[] = { "?", "KEEP",
 "CONVERT", "RESTORE" };
static char *_KUIP_SET_SHOW_FILECASE_OPTION_text[] = { "show current setting",
 "filenames are kept as entered on the command line",
 "filenames are case converted", "restore previous FILECASE setting" };
static KmParOption _KUIP_SET_SHOW_FILECASE_OPTION_type = {
 _KUIP_SET_SHOW_FILECASE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _KUIP_SET_SHOW_FILECASE_OPTION = { "OPTION", 6,
 "Case conversion for filenames", "?", (char*)0, 8, 4,
 _KUIP_SET_SHOW_FILECASE_OPTION_range, 4,
 _KUIP_SET_SHOW_FILECASE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_SET_SHOW_FILECASE_OPTION_type };
static KmParameter *_KUIP_SET_SHOW_FILECASE_parameters[] = {
 &_KUIP_SET_SHOW_FILECASE_OPTION };
static char *_KUIP_SET_SHOW_FILECASE_guidance[] = {
 "Set or show the case conversion for filenames.", "",
 "This command has only an effect on Unix systems to select whether\
 filenames", "are kept as entered on the command line.",
 "The startup value is 'CONVERT', i.e. filenames are converted to lowercase.",
 "", "On other systems filenames are always converted to uppercase.", "",
 "The 'RESTORE' option set the conversion mode to the value effective",
 "before the last FILECASE KEEP/CONVERT command.", "E.g. the sequence",
 "     FILECASE KEEP; EDIT Read.Me; FILECASE RESTORE",
 "forces case sensitivity for the EDIT command and restores the previous\
 mode", "afterwards." };
static char *_KUIP_SET_SHOW_FILECASE_keyword[] = { "FILE", "filename", "name",
 "conversion", "Case", "upper", "lower" };
static KmCommand _KUIP_SET_SHOW_FILECASE = { &_KUIP_SET_SHOW_LCDIR,
 "/KUIP/SET_SHOW/FILECASE", "FILECASE", 0, 2, 1, 0,
 _KUIP_SET_SHOW_FILECASE_parameters, 0, 0, (SUBROUTINE*)0, kxfilecase,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _KUIP_SET_SHOW_FILECASE_guidance, 7,
 _KUIP_SET_SHOW_FILECASE_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_KUIP_SET_SHOW_DOLLAR_OPTION_range[] = { "?", "ON", "OFF" };
static char *_KUIP_SET_SHOW_DOLLAR_OPTION_text[] = { "show current setting",
 "enable substitution", "disable substitution" };
static KmParOption _KUIP_SET_SHOW_DOLLAR_OPTION_type = {
 _KUIP_SET_SHOW_DOLLAR_OPTION_text, (int*)0, (int*)0 };
static KmParameter _KUIP_SET_SHOW_DOLLAR_OPTION = { "OPTION", 6,
 "Substitution of environment variables", "?", (char*)0, 8, 3,
 _KUIP_SET_SHOW_DOLLAR_OPTION_range, 3, _KUIP_SET_SHOW_DOLLAR_OPTION_range,
 (KmParFlag)0, KmTYPE_OPTION, &_KUIP_SET_SHOW_DOLLAR_OPTION_type };
static KmParameter *_KUIP_SET_SHOW_DOLLAR_parameters[] = {
 &_KUIP_SET_SHOW_DOLLAR_OPTION };
static char *_KUIP_SET_SHOW_DOLLAR_guidance[] = {
 "Set or show the status of environment variable substitution.", "",
 "This command allows to enable/disable the interpretation of",
 "environment variables in command lines.",
 "The startup value is 'ON', i.e. \"$var\" is substituted by the variable\
 value.", "",
 "Note that the system function \"$ENV(var)\" allows using environment\
 variables", "even for 'DOLLAR OFF' ." };
static char *_KUIP_SET_SHOW_DOLLAR_keyword[] = { "environment", "variable",
 "substite", "substitution" };
static KmCommand _KUIP_SET_SHOW_DOLLAR = { &_KUIP_SET_SHOW_FILECASE,
 "/KUIP/SET_SHOW/DOLLAR", "DOLLAR", 0, 2, 1, 0,
 _KUIP_SET_SHOW_DOLLAR_parameters, 0, 0, (SUBROUTINE*)0, kxdollar,
 (SUBROUTINE*)0, (pCharFunc*)0, 8, _KUIP_SET_SHOW_DOLLAR_guidance, 4,
 _KUIP_SET_SHOW_DOLLAR_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0
 };

static KmParameter _KUIP_SET_SHOW_VISIBILITY_CMD = { "CMD", 3, "Command name",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static char *_KUIP_SET_SHOW_VISIBILITY_CHOPT_range[] = { "?", "OFF", "ON" };
static char *_KUIP_SET_SHOW_VISIBILITY_CHOPT_text[] = { (char*)0, (char*)0,
 (char*)0 };
static KmParOption _KUIP_SET_SHOW_VISIBILITY_CHOPT_type = {
 _KUIP_SET_SHOW_VISIBILITY_CHOPT_text, (int*)0, (int*)0 };
static KmParameter _KUIP_SET_SHOW_VISIBILITY_CHOPT = { "CHOPT", 5,
 "?, OFF, ON", "?", (char*)0, 8, 3, _KUIP_SET_SHOW_VISIBILITY_CHOPT_range, 3,
 _KUIP_SET_SHOW_VISIBILITY_CHOPT_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_SET_SHOW_VISIBILITY_CHOPT_type };
static KmParameter *_KUIP_SET_SHOW_VISIBILITY_parameters[] = {
 &_KUIP_SET_SHOW_VISIBILITY_CMD, &_KUIP_SET_SHOW_VISIBILITY_CHOPT };
static char *_KUIP_SET_SHOW_VISIBILITY_guidance[] = {
 "Set or show the visibility attributes of a command.", "", "If CHOPT='OFF':",
 " - the command it is not executable anymore",
 " - STYLE G draws a shadowed box on the command",
 " - HELP may be still requested on the command", "The startup value is ON." };
static KmCommand _KUIP_SET_SHOW_VISIBILITY = { &_KUIP_SET_SHOW_DOLLAR,
 "/KUIP/SET_SHOW/VISIBILITY", "VISIBILITY", 0, 2, 2, 1,
 _KUIP_SET_SHOW_VISIBILITY_parameters, 0, 0, (SUBROUTINE*)0, kxvisibility,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _KUIP_SET_SHOW_VISIBILITY_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_SET_SHOW_RECALL_STYLE_OPTION_range[] = { "?", "KSH",
 "KSHO", "DCL", "DCLO", "NONE" };
static char *_KUIP_SET_SHOW_RECALL_STYLE_OPTION_text[] = {
 "show current setting", "Korn shell : Emacs like command line editing",
 "Korn shell + Overwrite : like 'KSH' but overwrite instead of insert mode",
 "VAX/VMS DCL : DCL command line editing",
 "VAX/VMS DCL + Overwrite : like 'DCL' but overwrite instead of insert mode",
 "disable command line editing" };
static KmParOption _KUIP_SET_SHOW_RECALL_STYLE_OPTION_type = {
 _KUIP_SET_SHOW_RECALL_STYLE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _KUIP_SET_SHOW_RECALL_STYLE_OPTION = { "OPTION", 6,
 "Command recall and editing style", "?", (char*)0, 8, 6,
 _KUIP_SET_SHOW_RECALL_STYLE_OPTION_range, 6,
 _KUIP_SET_SHOW_RECALL_STYLE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_SET_SHOW_RECALL_STYLE_OPTION_type };
static KmParameter *_KUIP_SET_SHOW_RECALL_STYLE_parameters[] = {
 &_KUIP_SET_SHOW_RECALL_STYLE_OPTION };
static char *_KUIP_SET_SHOW_RECALL_STYLE_guidance[] = {
 "Set the command recall and editing style.",
 "If OPTION='?' the current style is shown.",
 "The startup value is 'DCL' on VAX/VMS, 'NONE' on Cray and Apollo DM pads,",
 "and 'KSH' on other systems.", "",
 "If the terminal emulator returns ANSI escape sequences (hpterm doesn't!)",
 "the up/down arrow keys can be used to recall items from the command\
 history", "list and the left/right arrow keys to move the cursor.", "",
 "'KSH' style provides the following control keys for editing:",
 "  ^A/^E   : Move cursor to beginning/end of the line.",
 "  ^F/^B   : Move cursor forward/backward one character.",
 "  ^D      : Delete the character under the cursor.",
 "  ^H, DEL : Delete the character to the left of the cursor.",
 "  ^K      : Kill from the cursor to the end of line.",
 "  ^L      : Redraw current line.",
 "  ^O      : Toggle overwrite/insert mode. Text added in overwrite mode",
 "            (including yanks) overwrites existing text, while insert mode",
 "            does not overwrite.",
 "  ^P/^N   : Move to previous/next item on history list.",
 "  ^R/^S   : Perform incremental reverse/forward search for string on",
 "            the history list.  Typing normal characters adds to the",
 "            current search string and searches for a match.  Typing",
 "            ^R/^S marks the start of a new search, and moves on to",
 "            the next match.  Typing ^H or DEL deletes the last",
 "            character from the search string, and searches from the",
 "            starting location of the last search.",
 "            Therefore, repeated DELs appear to unwind to the match",
 "            nearest the point at which the last ^R or ^S was typed.",
 "            If DEL is repeated until the search string is empty the",
 "            search location begins from the start of the history",
 "            list. Typing ESC or any other editing character accepts",
 "            the current match and loads it into the buffer,",
 "            terminating the search.",
 "  ^T      : Toggle the characters under and to the left of the cursor.",
 "  ^U      : Kill from the prompt to the end of line.",
 "  ^Y      : Yank previously killed text back at current location.",
 "            Note that this will overwrite or insert, depending on",
 "            the current mode.",
 "  TAB     : By default adds spaces to buffer to get to next TAB stop",
 "            (just after every 8th column).",
 "  LF, CR  : Returns current buffer to the program.", "",
 "'DCL' style provides the following control keys for editing:",
 "  BS/^E   : Move cursor to beginning/end of the line.",
 "  ^F/^D   : Move cursor forward/backward one character.",
 "  DEL     : Delete the character to the left of the cursor.",
 "  ^A      : Toggle overwrite/insert mode.",
 "  ^B      : Move to previous item on history list.",
 "  ^U      : Delete from the beginning of the line to the cursor.",
 "  TAB     : Move to next TAB stop.",
 "  LF, CR  : Returns current buffer to the program." };
static char *_KUIP_SET_SHOW_RECALL_STYLE_keyword[] = { "STYLE", "mode" };
static KmCommand _KUIP_SET_SHOW_RECALL_STYLE = { &_KUIP_SET_SHOW_VISIBILITY,
 "/KUIP/SET_SHOW/RECALL_STYLE", "RECALL_STYLE", 0, 2, 1, 0,
 _KUIP_SET_SHOW_RECALL_STYLE_parameters, 0, 0, (SUBROUTINE*)0, kxrecallstyle,
 (SUBROUTINE*)0, (pCharFunc*)0, 52, _KUIP_SET_SHOW_RECALL_STYLE_guidance, 2,
 _KUIP_SET_SHOW_RECALL_STYLE_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _KUIP_SET_SHOW_HOST_SHELL_SHELL = { "SHELL", 5,
 "Host shell command", "?", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_HOST_SHELL_parameters[] = {
 &_KUIP_SET_SHOW_HOST_SHELL_SHELL };
static char *_KUIP_SET_SHOW_HOST_SHELL_guidance[] = {
 "Set the default host shell invoked by the KUIP/SHELL command.",
 "If OPTION='?' the current host shell is shown.",
 "The startup value is taken from the 'SHELL' environment variable." };
static char *_KUIP_SET_SHOW_HOST_SHELL_keyword[] = { "SHELL" };
static KmCommand _KUIP_SET_SHOW_HOST_SHELL = { &_KUIP_SET_SHOW_RECALL_STYLE,
 "/KUIP/SET_SHOW/HOST_SHELL", "HOST_SHELL", 0, 2, 1, 0,
 _KUIP_SET_SHOW_HOST_SHELL_parameters, 0, 0, (SUBROUTINE*)0, kxhostshell,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _KUIP_SET_SHOW_HOST_SHELL_guidance, 1,
 _KUIP_SET_SHOW_HOST_SHELL_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _KUIP_SET_SHOW_HOST_PSVIEWER_PSVIEWER = { "PSVIEWER", 8,
 "Host PostScript Viewer command", "?", (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_HOST_PSVIEWER_parameters[] = {
 &_KUIP_SET_SHOW_HOST_PSVIEWER_PSVIEWER };
static char *_KUIP_SET_SHOW_HOST_PSVIEWER_guidance[] = {
 "Set the host command to invoke the PostScript Viewer.",
 "The PSVIEW command will invoke this PostScript Viewer.",
 "If PSVIEWER='?' then the current viewer command is shown.", "",
 "The startup value can be defined by the environment variables",
 "'KUIPPSVIEWER' or 'PSVIEWER'.", "",
 "On Unix workstations it is by default set to 'ghostview'.",
 "On VAX/VMS the default commands is 'VIEW/FORM=PS/INTERFACE=DECWINDOWS'." };
static char *_KUIP_SET_SHOW_HOST_PSVIEWER_keyword[] = { "PSVIEWER",
 "PostScript", "viewer" };
static KmCommand _KUIP_SET_SHOW_HOST_PSVIEWER = { &_KUIP_SET_SHOW_HOST_SHELL,
 "/KUIP/SET_SHOW/HOST_PSVIEWER", "HOST_PSVIEWER", 0, 2, 1, 0,
 _KUIP_SET_SHOW_HOST_PSVIEWER_parameters, 0, 0, (SUBROUTINE*)0,
 kxhostpsviewer, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _KUIP_SET_SHOW_HOST_PSVIEWER_guidance, 3,
 _KUIP_SET_SHOW_HOST_PSVIEWER_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _KUIP_SET_SHOW_HOST_PRINTER_COMMAND = { "COMMAND", 7,
 "Host printer command", "?", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _KUIP_SET_SHOW_HOST_PRINTER_FILETYPE = { "FILETYPE", 8,
 "File extension", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_HOST_PRINTER_parameters[] = {
 &_KUIP_SET_SHOW_HOST_PRINTER_COMMAND, &_KUIP_SET_SHOW_HOST_PRINTER_FILETYPE };
static char *_KUIP_SET_SHOW_HOST_PRINTER_guidance[] = {
 "Set the host commands for printing files with KUIP/PRINT.",
 "The KUIP/PRINT command will use the host command matching the file",
 "extension or use the default command defined for FILETYPE=' '.", "",
 "If COMMAND='?' the currently set commands are shown.",
 "If COMMAND=' ' the currently defined command is delete.",
 "The command string can contain '$*' and '$-' to indicate the position",
 "where the file name with/without file extension should be inserted.",
 "For example,", " MANUAL / refman.tex latex",
 " HOST_PRINTER 'latex $* ; dvips $-' .tex", " KUIP/PRINT refman.tex",
 "invokes the shell command 'latex refman.tex ; dvips refman'.",
 "The predefined defaults are not guaranteed to work",
 "since the actual print commands are very much installation dependent." };
static char *_KUIP_SET_SHOW_HOST_PRINTER_keyword[] = { "PRINTER", "PRINT" };
static KmCommand _KUIP_SET_SHOW_HOST_PRINTER = {
 &_KUIP_SET_SHOW_HOST_PSVIEWER, "/KUIP/SET_SHOW/HOST_PRINTER", "HOST_PRINTER",
 0, 2, 2, 0, _KUIP_SET_SHOW_HOST_PRINTER_parameters, 0, 0, (SUBROUTINE*)0,
 kxhostprinter, (SUBROUTINE*)0, (pCharFunc*)0, 15,
 _KUIP_SET_SHOW_HOST_PRINTER_guidance, 2, _KUIP_SET_SHOW_HOST_PRINTER_keyword,
 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_SET_SHOW_HOST_PAGER_PAGER = { "PAGER", 5,
 "Host pager command", "?", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_HOST_PAGER_parameters[] = {
 &_KUIP_SET_SHOW_HOST_PAGER_PAGER };
static char *_KUIP_SET_SHOW_HOST_PAGER_guidance[] = {
 "Set the host command to view a file in read-only mode.",
 "If OPTION='?' the current host pager command is shown.",
 "The 'HELP -EDIT' command will invoke this pager, e.g.", " HOST_PAGER more",
 "", "On Unix workstations the pager can be asynchronous by creating a",
 "separate window, e.g.", " HOST_PAGER 'xterm -e view &'",
 " HOST_PAGER 'ved &'", "",
 "On Apollo the special value PAGER='DM' defines the use of",
 "Display Manager read-only pads.",
 "The pad positions can be adjusted by the HOST_EDITOR command.", "",
 "The startup value can be defined by the environment variables",
 "'KUIPPAGER' or 'PAGER'.",
 "If neither of them is defined the value set by the HOST_EDITOR command",
 "is used.", "On VAX/VMS the startup value is 'TYPE/PAGE'." };
static char *_KUIP_SET_SHOW_HOST_PAGER_keyword[] = { "PAGER", "view", "read",
 "more" };
static KmCommand _KUIP_SET_SHOW_HOST_PAGER = { &_KUIP_SET_SHOW_HOST_PRINTER,
 "/KUIP/SET_SHOW/HOST_PAGER", "HOST_PAGER", 0, 2, 1, 0,
 _KUIP_SET_SHOW_HOST_PAGER_parameters, 0, 0, (SUBROUTINE*)0, kxhostpager,
 (SUBROUTINE*)0, (pCharFunc*)0, 19, _KUIP_SET_SHOW_HOST_PAGER_guidance, 4,
 _KUIP_SET_SHOW_HOST_PAGER_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_EDITOR = { "EDITOR", 6,
 "Host editor command", "?", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _KUIP_SET_SHOW_HOST_EDITOR_TOP_type = { "0", (char*)0, "0",
 (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_TOP = { "TOP", 3,
 "Top position of the edit window", "20", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_HOST_EDITOR_TOP_type };
static KmParInt    _KUIP_SET_SHOW_HOST_EDITOR_LEFT_type = { "0", (char*)0,
 "0", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_LEFT = { "LEFT", 4,
 "Left position of the edit window", "20", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_HOST_EDITOR_LEFT_type };
static KmParInt    _KUIP_SET_SHOW_HOST_EDITOR_WIDTH_type = { "0", (char*)0,
 "0", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_WIDTH = { "WIDTH", 5,
 "Width of the edit window", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_HOST_EDITOR_WIDTH_type };
static KmParInt    _KUIP_SET_SHOW_HOST_EDITOR_HEIGHT_type = { "0", (char*)0,
 "0", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_HEIGHT = { "HEIGHT", 6,
 "Height of the edit window", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_HOST_EDITOR_HEIGHT_type };
static KmParInt    _KUIP_SET_SHOW_HOST_EDITOR_DXPAD_type = { "0", (char*)0,
 "0", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_DXPAD = { "DXPAD", 5,
 "X offset for help PAD windows", "30", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_HOST_EDITOR_DXPAD_type };
static KmParInt    _KUIP_SET_SHOW_HOST_EDITOR_DYPAD_type = { "0", (char*)0,
 "0", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_DYPAD = { "DYPAD", 5,
 "Y offset for help PAD windows", "20", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_HOST_EDITOR_DYPAD_type };
static KmParInt    _KUIP_SET_SHOW_HOST_EDITOR_NPADS_type = { "1", (char*)0,
 "1", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_HOST_EDITOR_NPADS = { "NPADS", 5,
 "Maximum number of shifted pads", "4", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_HOST_EDITOR_NPADS_type };
static KmParameter *_KUIP_SET_SHOW_HOST_EDITOR_parameters[] = {
 &_KUIP_SET_SHOW_HOST_EDITOR_EDITOR, &_KUIP_SET_SHOW_HOST_EDITOR_TOP,
 &_KUIP_SET_SHOW_HOST_EDITOR_LEFT, &_KUIP_SET_SHOW_HOST_EDITOR_WIDTH,
 &_KUIP_SET_SHOW_HOST_EDITOR_HEIGHT, &_KUIP_SET_SHOW_HOST_EDITOR_DXPAD,
 &_KUIP_SET_SHOW_HOST_EDITOR_DYPAD, &_KUIP_SET_SHOW_HOST_EDITOR_NPADS };
static char *_KUIP_SET_SHOW_HOST_EDITOR_guidance[] = {
 "Set the host command to invoke the editor.",
 "The EDIT command will invoke this editor.",
 "If EDITOR='?' the current host editor command is shown.", "",
 "On Apollo the special value EDITOR='DM' invoke Display Manager pads.",
 "The special values EDITOR='WINDOW' and 'PAD' can be used to specify",
 "the window positions (in pixel units).",
 "'WINDOW' defines the parameters for edit pads,",
 "while 'PAD' defines the parameters for read-only pads",
 "(e.g. used by 'HELP -EDIT').", "",
 "On VMS the special values EDITOR='EDT' and 'TPU' invoke the callable",
 "editors.",
 "The startup time is considerably lower compared to spawning the editor",
 "as a subprocess.", "The callable EDT has one disadvantage though:",
 "after an error, e.g. trying to edit a file in a non-existing directory,",
 "subsequent calls will always fail.",
 "The TPU call can be augmented by command line options, e.g.",
 " HOST_EDITOR TPU/DISP=DECW    | DECwindow interface to EVE", "",
 "On Unix a variety of editors are available, e.g.", " HOST_EDITOR vi",
 " HOST_EDITOR 'emacs -geometry 80x48'", "",
 "On Unix workstations it is possible to do asynchronous editing",
 "via the KUIP edit server,",
 "i.e. to start an editor in a separate window while the application",
 "can continue to receive commands.",
 "In order to do that the following conditions must be fulfilled:",
 " - The KUIP edit server 'kuesvr' must be found in the search path.",
 " - The editor command set by HOST_EDITOR must end with an ampersand ('&').",
 " - The environment variable 'DISPLAY' must be set.", "",
 "The ampersand flags your intention to use the edit server if possible.",
 "If the edit server cannot be used the ampersand will be ignored,",
 "i.e. even with", " HOST_EDITOR 'vi &'",
 "the KUIP/EDIT command will block until the editor terminates",
 "if either the 'kuesvr' is not available or 'DISPLAY' is undefined.",
 "When using the edit server the editor command is expected to create",
 "its own window.",
 "'vi' being a frequent choice, the above command is automatically",
 "interpreted as", " HOST_EDITOR 'xterm -e vi &'", "",
 "The startup value can be defined by the environment variable 'EDITOR'.",
 "Otherwise it is set to a system dependent default:",
 "'DM' (Apollo), 'EDT' (VMS), 'XEDIT' (VM/CMS), 'vi' (Unix)." };
static char *_KUIP_SET_SHOW_HOST_EDITOR_keyword[] = { "EDITOR", "edit", "vi",
 "emacs", "TPU", "EDIT" };
static KmCommand _KUIP_SET_SHOW_HOST_EDITOR = { &_KUIP_SET_SHOW_HOST_PAGER,
 "/KUIP/SET_SHOW/HOST_EDITOR", "HOST_EDITOR", 0, 2, 8, 0,
 _KUIP_SET_SHOW_HOST_EDITOR_parameters, 0, 0, (SUBROUTINE*)0, kxhosteditor,
 (SUBROUTINE*)0, (pCharFunc*)0, 49, _KUIP_SET_SHOW_HOST_EDITOR_guidance, 6,
 _KUIP_SET_SHOW_HOST_EDITOR_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _KUIP_SET_SHOW_RECORDING_NREC_type = { "0", (char*)0, "0",
 (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_RECORDING_NREC = { "NREC", 4,
 "Rate for recording on history file", "25", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_RECORDING_NREC_type };
static KmParameter *_KUIP_SET_SHOW_RECORDING_parameters[] = {
 &_KUIP_SET_SHOW_RECORDING_NREC };
static char *_KUIP_SET_SHOW_RECORDING_guidance[] = {
 "Set the recording rate for the history file.",
 "Every NREC commands of the session the current history file is updated.",
 "If NREC=0 the history is not kept at all (i.e. the file is not written).",
 "See also the command LAST." };
static char *_KUIP_SET_SHOW_RECORDING_keyword[] = { "RECORD", "history",
 "file", "LAST" };
static KmCommand _KUIP_SET_SHOW_RECORDING = { &_KUIP_SET_SHOW_HOST_EDITOR,
 "/KUIP/SET_SHOW/RECORDING", "RECORDING", 0, 2, 1, 0,
 _KUIP_SET_SHOW_RECORDING_parameters, 0, 0, (SUBROUTINE*)0, kxrecording,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _KUIP_SET_SHOW_RECORDING_guidance, 4,
 _KUIP_SET_SHOW_RECORDING_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParInt    _KUIP_SET_SHOW_COLUMNS_NCOL_type = { "-1", (char*)0, "-1",
 (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_COLUMNS_NCOL = { "NCOL", 4,
 "Number of columns for terminal output", "80", (char*)0, 8, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_COLUMNS_NCOL_type };
static KmParameter *_KUIP_SET_SHOW_COLUMNS_parameters[] = {
 &_KUIP_SET_SHOW_COLUMNS_NCOL };
static char *_KUIP_SET_SHOW_COLUMNS_guidance[] = {
 "Set the maximum number of columns for terminal output.",
 "If NCOL=0 the current number of columns is shown.",
 "If NCOL=-1 the current number of columns is taken from the environment",
 "variable COLUMNS.", "If COLUMNS is undefined the startup value is 80." };
static KmCommand _KUIP_SET_SHOW_COLUMNS = { &_KUIP_SET_SHOW_RECORDING,
 "/KUIP/SET_SHOW/COLUMNS", "COLUMNS", 0, 2, 1, 0,
 _KUIP_SET_SHOW_COLUMNS_parameters, 0, 0, (SUBROUTINE*)0, kxcolumns,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _KUIP_SET_SHOW_COLUMNS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_SET_SHOW_BREAK_OPTION_range[] = { "ON", "OFF", "TB", "?" };
static char *_KUIP_SET_SHOW_BREAK_OPTION_text[] = { (char*)0, (char*)0,
 (char*)0, (char*)0 };
static KmParOption _KUIP_SET_SHOW_BREAK_OPTION_type = {
 _KUIP_SET_SHOW_BREAK_OPTION_text, (int*)0, (int*)0 };
static KmParameter _KUIP_SET_SHOW_BREAK_OPTION = { "OPTION", 6, "Option",
 "ON", (char*)0, 8, 4, _KUIP_SET_SHOW_BREAK_OPTION_range, 4,
 _KUIP_SET_SHOW_BREAK_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_SET_SHOW_BREAK_OPTION_type };
static KmParameter *_KUIP_SET_SHOW_BREAK_parameters[] = {
 &_KUIP_SET_SHOW_BREAK_OPTION };
static char *_KUIP_SET_SHOW_BREAK_guidance[] = {
 "Set ON/OFF the break handling.",
 "If OPTION='?' the current value is shown.", "The startup value is ON.", "",
 "Hitting the keyboard interrupt (CTRL/C on VMS or CTRL/Q on the Apollo)",
 "under break ON condition, the current command or macro execution",
 "will be interrupted and the user will get again the application prompt.",
 "", "BREAK TB switch ON the traceback of the routines called, with their",
 "line numbers, when an error occurs. This allows the detection of",
 "the routines which provoked the error." };
static char *_KUIP_SET_SHOW_BREAK_keyword[] = { "keyboard", "interrupt",
 "interruption", "macro" };
static KmCommand _KUIP_SET_SHOW_BREAK = { &_KUIP_SET_SHOW_COLUMNS,
 "/KUIP/SET_SHOW/BREAK", "BREAK", 0, 2, 1, 0, _KUIP_SET_SHOW_BREAK_parameters,
 0, 0, (SUBROUTINE*)0, kxbreak, (SUBROUTINE*)0, (pCharFunc*)0, 11,
 _KUIP_SET_SHOW_BREAK_guidance, 4, _KUIP_SET_SHOW_BREAK_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_SET_SHOW_PROMPT_PROMPT = { "PROMPT", 6,
 "Prompt string", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_PROMPT_parameters[] = {
 &_KUIP_SET_SHOW_PROMPT_PROMPT };
static char *_KUIP_SET_SHOW_PROMPT_guidance[] = {
 "Set the prompt string for the command mode dialogue.",
 "If PROMPT is blank the current prompt is left unchanged.",
 "If PROMPT contains the character sequence '[]'",
 "the current command number is inserted between the square brackets." };
static KmCommand _KUIP_SET_SHOW_PROMPT = { &_KUIP_SET_SHOW_BREAK,
 "/KUIP/SET_SHOW/PROMPT", "PROMPT", 0, 2, 1, 1,
 _KUIP_SET_SHOW_PROMPT_parameters, 0, 0, (SUBROUTINE*)0, kxprompt,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _KUIP_SET_SHOW_PROMPT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_SET_SHOW_TIMING_OPTION_range[] = { "ON", "OFF", "ALL" };
static char *_KUIP_SET_SHOW_TIMING_OPTION_text[] = { (char*)0, (char*)0,
 (char*)0 };
static KmParOption _KUIP_SET_SHOW_TIMING_OPTION_type = {
 _KUIP_SET_SHOW_TIMING_OPTION_text, (int*)0, (int*)0 };
static KmParameter _KUIP_SET_SHOW_TIMING_OPTION = { "OPTION", 6, "Option",
 "ON", (char*)0, 8, 3, _KUIP_SET_SHOW_TIMING_OPTION_range, 3,
 _KUIP_SET_SHOW_TIMING_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_SET_SHOW_TIMING_OPTION_type };
static KmParameter *_KUIP_SET_SHOW_TIMING_parameters[] = {
 &_KUIP_SET_SHOW_TIMING_OPTION };
static char *_KUIP_SET_SHOW_TIMING_guidance[] = {
 "Set ON/OFF/ALL the timing of commands.",
 "If ON, the real time and the CPU time for the latest",
 "executed command (or macro) are presented.",
 "If ALL, the time is shown for each command being executed within a macro.",
 "The startup value is OFF." };
static char *_KUIP_SET_SHOW_TIMING_keyword[] = { "time" };
static KmCommand _KUIP_SET_SHOW_TIMING = { &_KUIP_SET_SHOW_PROMPT,
 "/KUIP/SET_SHOW/TIMING", "TIMING", 0, 2, 1, 0,
 _KUIP_SET_SHOW_TIMING_parameters, 0, 0, (SUBROUTINE*)0, kxtiming,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _KUIP_SET_SHOW_TIMING_guidance, 1,
 _KUIP_SET_SHOW_TIMING_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0
 };

static KmParameter _KUIP_SET_SHOW_ROOT_PATH = { "PATH", 4, "Root directory",
 "/", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_KUIP_SET_SHOW_ROOT_parameters[] = {
 &_KUIP_SET_SHOW_ROOT_PATH };
static char *_KUIP_SET_SHOW_ROOT_guidance[] = {
 "Set the root for searching commands.",
 "If PATH='?' the current root is shown.",
 "This allows to access commands regardless of possible",
 "ambiguities with different menus.",
 "Commands are first searched starting from the current root:",
 "if a command is found it is executed.",
 "Only if a command is not found a second pass of search is done,",
 "starting now from the top root of the command tree (i.e. '/')." };
static char *_KUIP_SET_SHOW_ROOT_keyword[] = { "command", "search",
 "searching" };
static KmCommand _KUIP_SET_SHOW_ROOT = { &_KUIP_SET_SHOW_TIMING,
 "/KUIP/SET_SHOW/ROOT", "ROOT", 0, 2, 1, 0, _KUIP_SET_SHOW_ROOT_parameters, 0,
 0, (SUBROUTINE*)0, kxroot, (SUBROUTINE*)0, (pCharFunc*)0, 8,
 _KUIP_SET_SHOW_ROOT_guidance, 3, _KUIP_SET_SHOW_ROOT_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_SET_SHOW_APPLICATION_PATH = { "PATH", 4,
 "Application name", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _KUIP_SET_SHOW_APPLICATION_CMDEX = { "CMDEX", 5,
 "Exit command", "EXIT", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_APPLICATION_parameters[] = {
 &_KUIP_SET_SHOW_APPLICATION_PATH, &_KUIP_SET_SHOW_APPLICATION_CMDEX };
static char *_KUIP_SET_SHOW_APPLICATION_guidance[] = {
 "Set the application name.",
 "This means that all input lines will be concatenated to the string PATH",
 "(until the command specified by the parameter CMDEX is executed,",
 "which resets the application to the null string). The value of CMDEX",
 "may be specified if the default value EXIT has to be changed",
 "(i.e. because already used by the application).",
 "APPLICATION can also be inserted in a macro: in this case at least",
 "4 characters must be specified (i.e. APPL)." };
static KmCommand _KUIP_SET_SHOW_APPLICATION = { &_KUIP_SET_SHOW_ROOT,
 "/KUIP/SET_SHOW/APPLICATION", "APPLICATION", 0, 2, 2, 1,
 _KUIP_SET_SHOW_APPLICATION_parameters, 0, 0, (SUBROUTINE*)0, kxapplication,
 (SUBROUTINE*)0, (pCharFunc*)0, 8, _KUIP_SET_SHOW_APPLICATION_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _KUIP_SET_SHOW_COMMAND_CHPATH = { "CHPATH", 6,
 "Path name for command line", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_COMMAND_parameters[] = {
 &_KUIP_SET_SHOW_COMMAND_CHPATH };
static char *_KUIP_SET_SHOW_COMMAND_guidance[] = {
 "Set a filter for the parsing of command lines.",
 "If it has been called, it means that whenever a command line is entered,",
 "if and only if it is not an existing command (not just ambiguous),",
 "it is inserted into the CHPATH string, with $n (n=1..9) being replaced",
 "by the n-th token of the command (tokens are separated by spaces),",
 "or $* being replaced by the whole command line. Examples:",
 " COMMAND 'V/CR $*(10)'", " AA                     =>   V/CR AA(10)",
 " BB                     =>   V/CR BB(10)",
 " V/LIST                 =>   V/LIST", "",
 " COMMAND 'VECTOR/PLOT $1 555 $2'",
 " AA E                   =>   VECTOR/PLOT AA 555 E",
 " BB                     =>   VECTOR/PLOT BB 555", "",
 " COMMAND                =>   shows its current value",
 " COMMAND *              =>   reset (equivalent to COMMAND $*)",
 "Note that COMMAND and subsequent command lines can be used inside macros,",
 "excepted when producing macro statements (like EXEC, IF, GOTO, etc.).",
 "For example, the above examples would work also inside macros, while",
 "COMMAND 'EXEC $*' or COMMAND 'GOTO $1' will not." };
static char *_KUIP_SET_SHOW_COMMAND_keyword[] = { "filter" };
static KmCommand _KUIP_SET_SHOW_COMMAND = { &_KUIP_SET_SHOW_APPLICATION,
 "/KUIP/SET_SHOW/COMMAND", "COMMAND", 0, 2, 1, 0,
 _KUIP_SET_SHOW_COMMAND_parameters, 0, 0, (SUBROUTINE*)0, kxcommand,
 (SUBROUTINE*)0, (pCharFunc*)0, 21, _KUIP_SET_SHOW_COMMAND_guidance, 1,
 _KUIP_SET_SHOW_COMMAND_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0
 };

static KmParInt    _KUIP_SET_SHOW_NEWPANEL_LINE_type = { "1", "30", "1", "30",
 0 };
static KmParameter _KUIP_SET_SHOW_NEWPANEL_LINE = { "LINE", 4,
 "Number of lines", "5", (char*)0, 3, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_NEWPANEL_LINE_type };
static KmParInt    _KUIP_SET_SHOW_NEWPANEL_COL_type = { "1", "30", "1", "30",
 0 };
static KmParameter _KUIP_SET_SHOW_NEWPANEL_COL = { "COL", 3,
 "Number of columns", "5", (char*)0, 3, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_NEWPANEL_COL_type };
static KmParameter _KUIP_SET_SHOW_NEWPANEL_TITLE = { "TITLE", 5,
 "Panel Title", "NewPanel", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParInt    _KUIP_SET_SHOW_NEWPANEL_WIDTH_type = { "10", (char*)0,
 "10", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_NEWPANEL_WIDTH = { "WIDTH", 5,
 "Panel width (in pixels)", "300", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_NEWPANEL_WIDTH_type };
static KmParInt    _KUIP_SET_SHOW_NEWPANEL_HEIGHT_type = { "10", (char*)0,
 "10", (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_NEWPANEL_HEIGHT = { "HEIGHT", 6,
 "Panel height (in pixels)", "300", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_NEWPANEL_HEIGHT_type };
static KmParInt    _KUIP_SET_SHOW_NEWPANEL_XPOS_type = { "0", (char*)0, "0",
 (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_NEWPANEL_XPOS = { "XPOS", 4,
 "X Position (in pixels)", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_NEWPANEL_XPOS_type };
static KmParInt    _KUIP_SET_SHOW_NEWPANEL_YPOS_type = { "0", (char*)0, "0",
 (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_NEWPANEL_YPOS = { "YPOS", 4,
 "Y Position (in pixels)", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_NEWPANEL_YPOS_type };
static KmParameter *_KUIP_SET_SHOW_NEWPANEL_parameters[] = {
 &_KUIP_SET_SHOW_NEWPANEL_LINE, &_KUIP_SET_SHOW_NEWPANEL_COL,
 &_KUIP_SET_SHOW_NEWPANEL_TITLE, &_KUIP_SET_SHOW_NEWPANEL_WIDTH,
 &_KUIP_SET_SHOW_NEWPANEL_HEIGHT, &_KUIP_SET_SHOW_NEWPANEL_XPOS,
 &_KUIP_SET_SHOW_NEWPANEL_YPOS };
static char *_KUIP_SET_SHOW_NEWPANEL_guidance[] = {
 "Set up a new panel with empty keys.",
 "This new panel must then be filled interactively." };
static char *_KUIP_SET_SHOW_NEWPANEL_keyword[] = { "panel" };
static KmCommand _KUIP_SET_SHOW_NEWPANEL = { &_KUIP_SET_SHOW_COMMAND,
 "/KUIP/SET_SHOW/NEWPANEL", "NEWPANEL", 0, 2, 7, 7,
 _KUIP_SET_SHOW_NEWPANEL_parameters, 0, 0, (SUBROUTINE*)0, kxnewpan,
 (SUBROUTINE*)0, (pCharFunc*)0, 2, _KUIP_SET_SHOW_NEWPANEL_guidance, 1,
 _KUIP_SET_SHOW_NEWPANEL_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParReal   _KUIP_SET_SHOW_PANEL_LINE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_PANEL_LINE = { "LINE", 4, "Line number",
 "0", (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_REAL,
 &_KUIP_SET_SHOW_PANEL_LINE_type };
static KmParameter _KUIP_SET_SHOW_PANEL_GKEY = { "GKEY", 4,
 "Graphics key value(s)", " ", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_KUIP_SET_SHOW_PANEL_parameters[] = {
 &_KUIP_SET_SHOW_PANEL_LINE, &_KUIP_SET_SHOW_PANEL_GKEY };
static char *_KUIP_SET_SHOW_PANEL_guidance[] = {
 "Set up a (user-definable) panel of commands with graphics keys.",
 "These keys are associated to pre-defined commands (or list of commands),",
 "which are generally corresponding to actions frequently executed.", "",
 "The \"panel interface\" is available in \"STYLE GP\" and in KUIP/Motif",
 "(but not in the basic command mode). Nevertheless the syntax of",
 "the PANEL command is different in these two modes of interface.",
 "The \"panel interface\" is a lot more powerful in KUIP/Motif,",
 "which means that the command is more complex.", "",
 "N.B. in \"STYLE GP\" only one panel of commands can be set up,",
 "whereas in KUIP/Motif there is no limitation.", "",
 "Syntax of the command in \"STYLE GP\" :", "", " PANEL x.y command", "",
 " where:", " x,y       is the key position (column and row number)",
 " command   is the complete command name (or list of commands)",
 "           to be excuted when the button is pressed.", "", "Examples:",
 " PANEL  0                        | reset the panel (in memory)",
 " PANEL  2.04 MESSAGE             | initialize 4th key of 2nd line to\
 MESSAGE", " PANEL  2.04                     | clear 4th key of 2nd line",
 "Note that the key number on the right of the decimal point must",
 "always be defined with two digits.", "",
 "Keys ending with a minus sign make an additional request of keyboard\
 input;",
 "the complete command line will be the key text, with a blank at the place",
 "of the minus, concatenated with the additional keyboard input. Example:",
 " PANEL 1.03 'VEC/PRI-'        | entering VAB will execute VEC/PRI VAB.",
 "Keys ending with a double minus sign behave as above but no blank is put",
 "at the place of the double minus. Example:",
 " PANEL 1.03 'VEC/PRI V--'     | entering AB will execute VEC/PRI VAB",
 "The dollar sign inside a key is replaced by additional keyboard input.\
 Example:",
 " PANEL 1.03 'VEC/PRI V($)'    | entering 11:20 will execute VEC/PRI\
 V(11:20)", "", "Syntax of the command in \"KUIP/Motif\" :", "",
 "All what is described above (for \"STYLE GP\") is still available.",
 "But the (more) general syntax in \"KUIP/Motif\" is:", "",
 " PANEL x.y command [label] [pixmap]", "", " where:",
 " x,y                is the key position (column and row number)",
 " command            is the complete command name (or list of commands)",
 "                    to be excuted when the button is pressed.",
 " label (optional)   is an alias name for this command. If specified,",
 "                    it is used for the button label (when the appropriate",
 "                    \"View\" option is selected) instead of the complete",
 "                    command (which is generally too long for a\
 \"user-friendly\"", "                    button label.",
 " pixmap (optional)  has to be specified when you want to have graphical\
 keys", "                    instead of pure text labels.", "",
 "In KUIP/Motif, the special value \"0\" for x.y (PANEL  0 ...) can be used",
 "for different purposes (according to the 2nd parameter value):", "",
 " PANEL  0 D [title] [geometry]", "",
 "can be use to display the current panel which is in memory with",
 "(optionals) a given title and geometry (size and position).", "",
 " PANEL  0 C [title]", "",
 "can be use to close the last panel, or the one corresponding to",
 "the given title.", "", "Examples:",
 " - PANEL  0 D 'This is my first panel' 500x300+500+600",
 "displays the panel which has been set in memory by the key definition,",
 "and sets the title to ``This is my first panel'', the window size to",
 "``500x300'' (WxH) and the window position to ``500 600'' in x and y.",
 "If no title and/or no geometry is specified one is given by default.",
 " - PANEL  0 C 'This is my first panel'",
 "closes (destroys and erases from the screen) the panel whith title",
 "``This is my first panel''.",
 "If no title is specified the last created panel is closed by default.", "",
 "As the \"panel interface\" is rather complex and powerful in KUIP-Motif,",
 "if you want to know all the possibilities, we invite you to refer to",
 "the KUIP User Guide (where you will also find picture illustrations)." };
static char *_KUIP_SET_SHOW_PANEL_keyword[] = { "interface", "command", "key",
 "pixmap", "graphics", "Motif", "STYLE" };
static KmCommand _KUIP_SET_SHOW_PANEL = { &_KUIP_SET_SHOW_NEWPANEL,
 "/KUIP/SET_SHOW/PANEL", "PANEL", 0, 2, 2, 1, _KUIP_SET_SHOW_PANEL_parameters,
 0, 0, (SUBROUTINE*)0, kxpanel, (SUBROUTINE*)0, (pCharFunc*)0, 85,
 _KUIP_SET_SHOW_PANEL_guidance, 7, _KUIP_SET_SHOW_PANEL_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_SET_SHOW_STYLE_OPTION_range[] = { "?", "C", "AN", "AL",
 "G", "GW", "GS", "GP", "XM" };
static char *_KUIP_SET_SHOW_STYLE_OPTION_text[] = { "show current style",
 "Command line : select Command line input",
 "Menu with Numbers : select general Alpha menu (with Numbers)",
 "Menu with Letters : select general Alpha menu (with Letters)",
 "Graphics menu hardware : select Graphics menu (with hardware character\
 fonts)",
 "Graphics menu shadowed : select Graphics menu (with shadowed Width effect)",
 "Graphics menu Software : select Graphics menu (with Software character\
 fonts)",
 "Panel keys : select Graphics menu (with Panel keys only, i.e. no command\
 tree menu)", "Motif/X11 : select Motif/X11 interface" };
static KmParOption _KUIP_SET_SHOW_STYLE_OPTION_type = {
 _KUIP_SET_SHOW_STYLE_OPTION_text, (int*)0, (int*)0 };
static KmParameter _KUIP_SET_SHOW_STYLE_OPTION = { "OPTION", 6, "Option", "?",
 (char*)0, 8, 9, _KUIP_SET_SHOW_STYLE_OPTION_range, 9,
 _KUIP_SET_SHOW_STYLE_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_KUIP_SET_SHOW_STYLE_OPTION_type };
static KmParReal   _KUIP_SET_SHOW_STYLE_SGYLEN_type = { "0.005", "0.25",
 "0.005", "0.25", 3 };
static KmParameter _KUIP_SET_SHOW_STYLE_SGYLEN = { "SGYLEN", 6,
 "max Y LENgth of each menu item box", "0.025", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_KUIP_SET_SHOW_STYLE_SGYLEN_type };
static KmParReal   _KUIP_SET_SHOW_STYLE_SGSIZE_type = { "0", "0.90", "0",
 "0.90", 2 };
static KmParameter _KUIP_SET_SHOW_STYLE_SGSIZE = { "SGSIZE", 6,
 "space available for the application", "0.8", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_KUIP_SET_SHOW_STYLE_SGSIZE_type };
static KmParReal   _KUIP_SET_SHOW_STYLE_SGYSPA_type = { "-0.5", "0.50",
 "-0.5", "0.50", 2 };
static KmParameter _KUIP_SET_SHOW_STYLE_SGYSPA = { "SGYSPA", 6,
 "max Y length of space between menus", "0.02", (char*)0, 12, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_REAL, &_KUIP_SET_SHOW_STYLE_SGYSPA_type };
static KmParReal   _KUIP_SET_SHOW_STYLE_SGBORD_type = { "0", "0.25", "0",
 "0.25", 2 };
static KmParameter _KUIP_SET_SHOW_STYLE_SGBORD = { "SGBORD", 6,
 "X or Y border for menus", "0.015", (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_KUIP_SET_SHOW_STYLE_SGBORD_type };
static KmParInt    _KUIP_SET_SHOW_STYLE_WKTYPE_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _KUIP_SET_SHOW_STYLE_WKTYPE = { "WKTYPE", 6,
 "Graphics workstation type", "0", (char*)0, 8, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_INT, &_KUIP_SET_SHOW_STYLE_WKTYPE_type };
static KmParameter *_KUIP_SET_SHOW_STYLE_parameters[] = {
 &_KUIP_SET_SHOW_STYLE_OPTION, &_KUIP_SET_SHOW_STYLE_SGYLEN,
 &_KUIP_SET_SHOW_STYLE_SGSIZE, &_KUIP_SET_SHOW_STYLE_SGYSPA,
 &_KUIP_SET_SHOW_STYLE_SGBORD, &_KUIP_SET_SHOW_STYLE_WKTYPE };
static char *_KUIP_SET_SHOW_STYLE_guidance[] = {
 "Select the user dialog style (or working mode).",
 "The startup value is 'C' (command mode).",
 "The current value is returned by the system function $STYLE.", "",
 "The G-styles are only available",
 "if the application program is calling KUWHAG instead of KUWHAT.",
 "When one of these options is choosen",
 "the remaining parameters control the geometrical layout",
 "of the menus on the screen and",
 "the graphics workstation type (in case HIGZ was not initialized).", "",
 "Style 'XM' is only available if the program is calling KUWHAM.",
 "In that case switching to other styles is not possible." };
static char *_KUIP_SET_SHOW_STYLE_keyword[] = { "dialog", "mode" };
static KmCommand _KUIP_SET_SHOW_STYLE = { &_KUIP_SET_SHOW_PANEL,
 "/KUIP/SET_SHOW/STYLE", "STYLE", 0, 2, 6, 0, _KUIP_SET_SHOW_STYLE_parameters,
 0, 0, (SUBROUTINE*)0, kxstyle, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _KUIP_SET_SHOW_STYLE_guidance, 2, _KUIP_SET_SHOW_STYLE_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static char *_KUIP_SET_SHOW_guidance[] = {
 "Set or show various KUIP parameters and options." };
static char *_KUIP_SET_SHOW_keyword[] = { "SHOW" };
static KmMenu _KUIP_SET_SHOW = {  (KmMenu*)0,  (KmMenu*)0, "/KUIP/SET_SHOW",
 "SET_SHOW", 2, &_KUIP_SET_SHOW_STYLE, 1, _KUIP_SET_SHOW_guidance, 1,
 _KUIP_SET_SHOW_keyword, 0, (char**)0 };

static char *_KUIP_ALIAS_guidance[] = { "Operations with aliases.",
 "Aliases are defined to provide shortcut abbreviations for the input line\
 or", "some part of it.",
 "When encountered on an input line an alias is replaced by its",
 "string value which can contain further aliases.",
 "(Be careful not to define recursive aliases.)", "",
 "To juxtaposition aliases, a double slash can be used as concatenation\
 sign.", "Inside quoted strings and for the ALIAS commands themselves",
 "the alias substitution is inhibited.", "Otherwise",
 " ALIAS/CREATE ALPHA BETA", " ALIAS/CREATE ALPHA BETA",
 "whould create an recursive alias BETA and", " ALIAS/CREATE ALPHA BETA",
 " ALIAS/CREATE BETA GAMMA", " ALIAS/DELETE ALPHA",
 "would delete the alias name BETA instead of ALPHA itself." };
static KmMenu _KUIP_ALIAS = { &_KUIP_SET_SHOW,  (KmMenu*)0, "/KUIP/ALIAS",
 "ALIAS", 2, &_KUIP_ALIAS_CREATE, 18, _KUIP_ALIAS_guidance, 0, (char**)0, 0,
 (char**)0 };

static KmMenu _KUIP = {  (KmMenu*)0, &_KUIP_ALIAS, "/KUIP", "KUIP", 1, 
 (KmCommand*)0, 0, (char**)0, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_KUIP, 950303 );
}


#ifdef F77_LCASE
#  define macdef_ macdef
#endif

#ifdef F77_UCASE
#  define macdef_ MACDEF
#endif

#ifdef IBM370
#  pragma linkage(MACDEF,FORTRAN)
#endif

extern void macdef_();

extern int kxglist();
extern int kxgdelete();
extern int kxgimport();
extern int kxgcreate();
extern int kxmdata();
extern int kxmdefaults();
extern int kxmtrace();
extern int kxmlist();
extern int kxmexec();

void macdef_()
{

static KmParameter _MACRO_GLOBAL_LIST_NAME = { "NAME", 4, "Variable name",
 "*", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter _MACRO_GLOBAL_LIST_FILE = { "FILE", 4, "Output file", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_MACRO_GLOBAL_LIST_parameters[] = {
 &_MACRO_GLOBAL_LIST_NAME, &_MACRO_GLOBAL_LIST_FILE };
static char *_MACRO_GLOBAL_LIST_guidance[] = { "List global variables.", "",
 "If a file name is specified the output is the list of GLOBAL/CREATE",
 "commands to define the selected global variables.",
 "The default file extension is .kumac." };
static KmCommand _MACRO_GLOBAL_LIST = {  (KmCommand*)0, "/MACRO/GLOBAL/LIST",
 "LIST", 0, 2, 2, 0, _MACRO_GLOBAL_LIST_parameters, 0, 0, (SUBROUTINE*)0,
 kxglist, (SUBROUTINE*)0, (pCharFunc*)0, 5, _MACRO_GLOBAL_LIST_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _MACRO_GLOBAL_DELETE_NAME = { "NAME", 4, "Variable name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_MACRO_GLOBAL_DELETE_parameters[] = {
 &_MACRO_GLOBAL_DELETE_NAME };
static char *_MACRO_GLOBAL_DELETE_guidance[] = { "Delete global variables.",
 "", "The global variables listed are deleted.",
 "The name may contain '*' as a wildcard matching any sequence of characters."
 };
static KmCommand _MACRO_GLOBAL_DELETE = { &_MACRO_GLOBAL_LIST,
 "/MACRO/GLOBAL/DELETE", "DELETE", 0, 2, 1, 1,
 _MACRO_GLOBAL_DELETE_parameters, 1, 0, (SUBROUTINE*)0, kxgdelete,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _MACRO_GLOBAL_DELETE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _MACRO_GLOBAL_IMPORT_NAME = { "NAME", 4, "Variable name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter *_MACRO_GLOBAL_IMPORT_parameters[] = {
 &_MACRO_GLOBAL_IMPORT_NAME };
static char *_MACRO_GLOBAL_IMPORT_guidance[] = { "Import global variables.",
 "", "If used inside a macro the variables listed are declared as global.",
 "The name may contain '*' as a wildcard matching any sequence of characters."
 };
static KmCommand _MACRO_GLOBAL_IMPORT = { &_MACRO_GLOBAL_DELETE,
 "/MACRO/GLOBAL/IMPORT", "IMPORT", 0, 2, 1, 1,
 _MACRO_GLOBAL_IMPORT_parameters, 1, 0, (SUBROUTINE*)0, kxgimport,
 (SUBROUTINE*)0, (pCharFunc*)0, 4, _MACRO_GLOBAL_IMPORT_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _MACRO_GLOBAL_CREATE_NAME = { "NAME", 4, "Variable name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _MACRO_GLOBAL_CREATE_VALUE = { "VALUE", 5, "Initial value",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter _MACRO_GLOBAL_CREATE_TEXT = { "TEXT", 4, "Comment text",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_MACRO_GLOBAL_CREATE_parameters[] = {
 &_MACRO_GLOBAL_CREATE_NAME, &_MACRO_GLOBAL_CREATE_VALUE,
 &_MACRO_GLOBAL_CREATE_TEXT };
static char *_MACRO_GLOBAL_CREATE_guidance[] = { "Create a global variable.",
 "", "If used inside a macro the variable [name] is declared as global." };
static char *_MACRO_GLOBAL_CREATE_keyword[] = { "variable" };
static KmCommand _MACRO_GLOBAL_CREATE = { &_MACRO_GLOBAL_IMPORT,
 "/MACRO/GLOBAL/CREATE", "CREATE", 0, 2, 3, 1,
 _MACRO_GLOBAL_CREATE_parameters, 1, 0, (SUBROUTINE*)0, kxgcreate,
 (SUBROUTINE*)0, (pCharFunc*)0, 3, _MACRO_GLOBAL_CREATE_guidance, 1,
 _MACRO_GLOBAL_CREATE_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Expressions_Garbage_guidance[] = {
 "Explanation of \"garbage\" expression syntax.", "",
 "Expressions which do not satisfy any of the other syntax rules we want to\
 call", "\"garbage\" expressions.  For example,", "",
 "        s = $OS$MACHINE", "",
 "is not a proper string expression. Unless they appear in a macro statement",
 "where specifically only an arithmetic or a boolean expression is allowed,\
 KUIP", "does not complain about these syntax errors. Instead the following",
 "transformations are applied:", "", "   o  alias substitution", "",
 "   o  macro variable replacement; values containing a",
 "      blank character are implicitly quoted", "",
 "   o  system function calls are replaced one by one with",
 "      their value provided that the argument is a syntactically",
 "      correct expression", "", "   o  string concatenation" };
static KmCommand _MACRO_SYNTAX_Expressions_Garbage = {  (KmCommand*)0,
 "/MACRO/SYNTAX/Expressions/Garbage", "Garbage", 0, 3, 0, 0, (KmParameter**)0,
 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 22,
 _MACRO_SYNTAX_Expressions_Garbage_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Expressions_String_guidance[] = {
 "Explanation of string expression syntax.", "",
 "String expressions can be used in the macro statements CASE, FOR, and EXITM,\
 in",
 "macro variable assignments, as system function arguments where a string\
 value",
 "is expected, or as the argument to the $EVAL function. They may be\
 constructed", "from the syntactic elements shown below.", "",
 "        string ::= quoted-string", "                 | unquoted-string",
 "                 | string // string             (concatenation)",
 "                 | expr // string               (expr represented as\
 string)", "                 | [variable-name]",
 "                 | alias-name", "                 | $system-function(...)" };
static char *_MACRO_SYNTAX_Expressions_String_keyword[] = { "CASE", "FOR",
 "EXITM" };
static KmCommand _MACRO_SYNTAX_Expressions_String = {
 &_MACRO_SYNTAX_Expressions_Garbage, "/MACRO/SYNTAX/Expressions/String",
 "String", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _MACRO_SYNTAX_Expressions_String_guidance,
 3, _MACRO_SYNTAX_Expressions_String_keyword, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Expressions_Boolean_guidance[] = {
 "Explanation of Boolean expression syntax.", "",
 "Boolean expressions can only be used in the macro statements IF, WHILE,\
 and", "REPEAT. The possible syntactic elements are shown below.", "",
 "         bool  ::= expr rel-op expr",
 "                 | string eq-op string",
 "                 | expr eq-op string", "                 | .NOT. bool",
 "                 | bool .AND. bool", "                 | bool .OR. bool",
 "                 | ( bool )", "",
 "        rel-op ::= .LT. | .LE. | .GT. | .GE.",
 "                 |  <   |  <=  |  >   |  >=", "                 | eq-op",
 "", "        eq-op  ::= .EQ. | .NE.", "                 |  =   | <>" };
static KmCommand _MACRO_SYNTAX_Expressions_Boolean = {
 &_MACRO_SYNTAX_Expressions_String, "/MACRO/SYNTAX/Expressions/Boolean",
 "Boolean", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 19,
 _MACRO_SYNTAX_Expressions_Boolean_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Expressions_Arithmetic_guidance[] = {
 "Explanation of arithmetic expression syntax.", "",
 "The syntactic elements for building arithmetic expressions are:", "",
 "        expr ::=  number",
 "                | vector-name                (for scalar vectors)",
 "                | vector-name(expr)",
 "                | vector-name(expr,expr)",
 "                | vector-name(expr,expr,expr)",
 "                | [variable-name]            (if value is numeric or",
 "                                              the name of a scalar vector)",
 "                | [variable-name](expr...)   (if value is a vector name)",
 "                | alias-name                 (if value is numeric\
 constant)", "                | $system-function(...)",
 "                | - expr", "                | expr + expr",
 "                | expr - expr", "                | expr * expr",
 "                | expr / expr", "                | (expr)",
 "                | ABS(expr)", "                | INT(expr)",
 "                | MOD(expr,expr)", "",
 "They can be used in the macro statements DO, FOR, and EXITM, in macro\
 variable",
 "assignments, as system function arguments where a numeric value is expected,\
 or", "as the argument to the $EVAL function.", "",
 "Note that all arithmetic operations are done in floating point, i.e.,\
 \"5/2\"",
 "becomes \"2.5\". If a floating point result appears in a place where an\
 integer", "is expected, for example as an index, the value is truncated." };
static KmCommand _MACRO_SYNTAX_Expressions_Arithmetic = {
 &_MACRO_SYNTAX_Expressions_Boolean, "/MACRO/SYNTAX/Expressions/Arithmetic",
 "Arithmetic", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 31,
 _MACRO_SYNTAX_Expressions_Arithmetic_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Variables_SHIFT_guidance[] = {
 "Manipulation numbered variables.", "",
 "The only possible manipulation of numbered variables is provided by the\
 SHIFT",
 "statement which copies [2] into [1], [3] into [2], etc., and discards the\
 value", "of the last defined numbered variable. For example, the construct",
 "", "        WHILE [1] <> ' ' DO", "          arg = [1]", "          ...",
 "          SHIFT", "        ENDDO", "",
 "allows to traverse the list of macro arguments." };
static KmCommand _MACRO_SYNTAX_Variables_SHIFT = {  (KmCommand*)0,
 "/MACRO/SYNTAX/Variables/SHIFT", "SHIFT", 0, 3, 0, 0, (KmParameter**)0, 0, 0,
 (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 13,
 _MACRO_SYNTAX_Variables_SHIFT_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Variables_READ_guidance[] = {
 "Reading a variable value from the keyboard.", "",
 "        READ name  [ prompt ]", "",
 "Variable values can be queried from the user during macro execution. The\
 READ",
 "statement prompts for the variable value. If name is already defined the",
 "present value will be proposed as default." };
static char *_MACRO_SYNTAX_Variables_READ_keyword[] = { "query" };
static KmCommand _MACRO_SYNTAX_Variables_READ = {
 &_MACRO_SYNTAX_Variables_SHIFT, "/MACRO/SYNTAX/Variables/READ", "READ", 0, 3,
 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 7, _MACRO_SYNTAX_Variables_READ_guidance, 1,
 _MACRO_SYNTAX_Variables_READ_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_MACRO_SYNTAX_Variables_Global_guidance[] = {
 "Declaring a global variable.", "", "        EXTERN name ...", "",
 "The variable names listed in the EXTERN statement are declared as",
 "global variables.",
 "If a name has not been defined with the GLOBAL/CREATE command,",
 "it is created implicitly and initialized to the empty string.",
 "The name list may contain wildcards, for example", "", "        EXTERN *",
 "", "makes all defined global variables visible." };
static char *_MACRO_SYNTAX_Variables_Global_keyword[] = { "EXTERN" };
static KmCommand _MACRO_SYNTAX_Variables_Global = {
 &_MACRO_SYNTAX_Variables_READ, "/MACRO/SYNTAX/Variables/Global", "Global", 0,
 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 13, _MACRO_SYNTAX_Variables_Global_guidance, 1,
 _MACRO_SYNTAX_Variables_Global_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_MACRO_SYNTAX_Variables_Indirection_guidance[] = {
 "Referencing a macro variable indirectly.", "",
 "Macro variables can be referenced indirectly. If the variable [name]\
 contains", "the name of another variable the construct", "",
 "        [%name]", "",
 "is substituted by that other variable's value.  For example, this is\
 another", "way to traverse the list of macro arguments:", "",
 "        DO i=1,[#]", "          arg = [%i]", "          ...",
 "        ENDDO", "",
 "There is only one level of indirection, i.e., the name contained in \"name\"\
 may", "not start with another \"%\"." };
static char *_MACRO_SYNTAX_Variables_Indirection_keyword[] = { "reference",
 "substitute", "substitution" };
static KmCommand _MACRO_SYNTAX_Variables_Indirection = {
 &_MACRO_SYNTAX_Variables_Global, "/MACRO/SYNTAX/Variables/Indirection",
 "Indirection", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 17,
 _MACRO_SYNTAX_Variables_Indirection_guidance, 3,
 _MACRO_SYNTAX_Variables_Indirection_keyword, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Variables_Special_guidance[] = {
 "Predefined special macro variables.", "",
 "For each macro the following special variables are always defined:", "",
 "        [0]     Fully qualified name of the macro.",
 "        [#]     Number of macro arguments",
 "        [*]     List of all macro arguments, separated by blanks",
 "        [@]     EXITM return code of the last macro called by",
 "                the current one.  The value is \"0\" if the last",
 "                macro did not supply a return code or no macro",
 "                has been called yet.", "",
 "As for numbered variables these names cannot be used on the left-hand side\
 of",
 "an assignment. The values or [#] and [*] are updated by the SHIFT\
 statement." };
static KmCommand _MACRO_SYNTAX_Variables_Special = {
 &_MACRO_SYNTAX_Variables_Indirection, "/MACRO/SYNTAX/Variables/Special",
 "Special", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _MACRO_SYNTAX_Variables_Special_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Variables_Numbered_guidance[] = {
 "Accessing macro arguments.", "",
 "The EXEC command can pass arguments to a macro. The arguments are assigned\
 to",
 "the numbered variables [1], [2], etc., in the order given in the EXEC\
 command.",
 "The name of the macro, including the file specification, is assigned to\
 [0].", "",
 "A numbered variable cannot be redefined, i.e., an assignment such as \"1 =\
 foo\"", "is illegal.  See MACRO/SYNTAX/SHIFT." };
static char *_MACRO_SYNTAX_Variables_Numbered_keyword[] = { "SHIFT" };
static KmCommand _MACRO_SYNTAX_Variables_Numbered = {
 &_MACRO_SYNTAX_Variables_Special, "/MACRO/SYNTAX/Variables/Numbered",
 "Numbered", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 8, _MACRO_SYNTAX_Variables_Numbered_guidance,
 1, _MACRO_SYNTAX_Variables_Numbered_keyword, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Definitions_ENDKUMAC_guidance[] = {
 "Ignore rest of KUMAC file.", "",
 "A logical \"end of file\" marker.  The KUIP parser will not read any part of\
 a", ".kumac file which appears after the \"ENDKUMAC\" command." };
static KmCommand _MACRO_SYNTAX_Definitions_ENDKUMAC = {  (KmCommand*)0,
 "/MACRO/SYNTAX/Definitions/ENDKUMAC", "ENDKUMAC", 0, 3, 0, 0,
 (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 4, _MACRO_SYNTAX_Definitions_ENDKUMAC_guidance, 0, (char**)0,
 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Definitions_STOPM_guidance[] = {
 "Terminate macro execution and return to command line prompt.", "",
 "        STOPM", "",
 "The STOPM statement unwinds nested macro calls and returns to",
 "the command line prompt." };
static KmCommand _MACRO_SYNTAX_Definitions_STOPM = {
 &_MACRO_SYNTAX_Definitions_ENDKUMAC, "/MACRO/SYNTAX/Definitions/STOPM",
 "STOPM", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 6, _MACRO_SYNTAX_Definitions_STOPM_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Definitions_EXITM_guidance[] = {
 "Terminate macro execution and return to calling macro.", "",
 "        EXITM [ value ]", "",
 "In order to return from a macro prematurely the EXITM statement must be\
 used.",
 "The value is stored into the variable [@] in the calling macro. If no value\
 is", "given it defaults to zero." };
static KmCommand _MACRO_SYNTAX_Definitions_EXITM = {
 &_MACRO_SYNTAX_Definitions_STOPM, "/MACRO/SYNTAX/Definitions/EXITM", "EXITM",
 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _MACRO_SYNTAX_Definitions_EXITM_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Definitions_RETURN_guidance[] = {
 "Ending a macro definition", "", "        RETURN [ value ]",
 "The RETURN statement flags the end of the macro definition and not the end\
 of", "macro execution, i.e., the construct", "", "        IF ... THEN",
 "          RETURN         | error!", "        ENDIF", "",
 "is illegal.  See MACRO/SYNTAX/EXITM.", "",
 "The value is stored into the variable [@] in the calling macro. If no value\
 is", "given it defaults to zero." };
static KmCommand _MACRO_SYNTAX_Definitions_RETURN = {
 &_MACRO_SYNTAX_Definitions_EXITM, "/MACRO/SYNTAX/Definitions/RETURN",
 "RETURN", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _MACRO_SYNTAX_Definitions_RETURN_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Definitions_MACRO_guidance[] = {
 "Defining a macro.", "", "A .kumac file may contain several macros.  An",
 "individual macro has the form", "",
 "        MACRO macro-name [ parameter-list ]", "           statements",
 "        RETURN", "",
 "Each statement is either a command line or one of the macro constructs",
 "described in this section (MACRO/SYNTAX).  For the first macro in the file\
 the",
 "MACRO header can be omitted.  For the last macro in the file the RETURN\
 trailer",
 "may be omitted.  Therefore a .kumac file containing only commands (like\
 the", "LAST.KUMAC) already constitutes a valid macro." };
static KmCommand _MACRO_SYNTAX_Definitions_MACRO = {
 &_MACRO_SYNTAX_Definitions_RETURN, "/MACRO/SYNTAX/Definitions/MACRO",
 "MACRO", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 14, _MACRO_SYNTAX_Definitions_MACRO_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Branching_ON_ERROR_guidance[] = {
 "Installing an error handler.", "",
 "Each command returns a status code which should be zero if the",
 "operation was successful or non-zero if any kind of error condition",
 "occurred.", "The status code can be tested by $IQUEST(1) system function.",
 "", "        ON ERROR GOTO label", "",
 "installs an error handler which tests the status code after each",
 "command and branches to the given label when a non-zero value is", "found.",
 "The error handler is local to each macro.", "",
 "        ON ERROR EXITM  [ expression ]", "and", "        ON ERROR STOPM",
 "", "are short-hand notations for a corresponding EXITM or STOPM statement",
 "at the targat label.", "", "        ON ERROR CONTINUE", "",
 "continues execution with the next command independent of the status",
 "code.", "This is the initial setting when entering a macro.", "",
 "        OFF ERROR", "",
 "An error handler can be deactivated by this statement.", "",
 "        ON ERROR", "",
 "An error handler can be reactivated by this statement." };
static KmCommand _MACRO_SYNTAX_Branching_ON_ERROR = {  (KmCommand*)0,
 "/MACRO/SYNTAX/Branching/ON_ERROR", "ON_ERROR", 0, 3, 0, 0, (KmParameter**)0,
 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 34,
 _MACRO_SYNTAX_Branching_ON_ERROR_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Branching_IF_THEN_guidance[] = {
 "Conditional execution of statement blocks.", "",
 "        IF expression THEN", "           statements",
 "        ELSEIF expression THEN", "           statements", "        ...",
 "        ELSEIF expression THEN", "           statements", "        ELSE",
 "           statements", "        ENDIF", "",
 "The general IF construct executes the statements following the first\
 IF/ELSEIF",
 "clause for with the boolean expression is true and then continues at the",
 "statement following the ENDIF. The ELSEIF clause can be repeated any number\
 of",
 "times or can be omitted altogether. If none of the expressions is true,\
 the", "statements following the optional ELSE clause are executed." };
static KmCommand _MACRO_SYNTAX_Branching_IF_THEN = {
 &_MACRO_SYNTAX_Branching_ON_ERROR, "/MACRO/SYNTAX/Branching/IF_THEN",
 "IF_THEN", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 18, _MACRO_SYNTAX_Branching_IF_THEN_guidance,
 0, (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Branching_GOTO_and_IF_GOTO_guidance[] = {
 "Unconditional and conditional branching.", "", "        GOTO label", "",
 "The simplest form of flow control is provided by the GOTO statement which",
 "continues execution at the statement following the target \"label:\". If the\
 jump",
 "leads into the scope of a block statement, for example a DO-loop, the result\
 is", "undefined.", "",
 "The target may be given by a variable containing the actual label name.",
 "", "        IF expression GOTO label", "",
 "This old-fashioned construct is equivalent to", "",
 "        IF expression THEN", "           GOTO label", "        ENDIF" };
static KmCommand _MACRO_SYNTAX_Branching_GOTO_and_IF_GOTO = {
 &_MACRO_SYNTAX_Branching_IF_THEN, "/MACRO/SYNTAX/Branching/GOTO_and_IF_GOTO",
 "GOTO_and_IF_GOTO", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 18,
 _MACRO_SYNTAX_Branching_GOTO_and_IF_GOTO_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Branching_CASE_guidance[] = {
 "Select one of many branches.", "", "        CASE expression IN",
 "        (label)  statement  [ statements ]", "        ...",
 "        (label)  statement  [ statements ]", "        ENDCASE", "",
 "The CASE switch evaluates the string expression and compares it one by one",
 "against the label lists until the first match is found. If a match is found\
 the",
 "statements up to the next label are executed before skipping to the\
 statement",
 "following the ENDCASE. None of the statements are executed if there is no\
 match", "with any label.", "",
 "Each label is a string constant and the comparison witht the selection",
 "expression is case-sensitive.",
 "If the same statement sequence should be executed for distinct values a",
 "comma-separated list of values can be used.", "",
 "The \"*\" character in a label item acts as wildcard matching any string of\
 zero", "or more characters, i.e., \"(*)\" constitutes the default label." };
static KmCommand _MACRO_SYNTAX_Branching_CASE = {
 &_MACRO_SYNTAX_Branching_GOTO_and_IF_GOTO, "/MACRO/SYNTAX/Branching/CASE",
 "CASE", 0, 3, 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 21, _MACRO_SYNTAX_Branching_CASE_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Looping_NEXTL_guidance[] = {
 "Continue with next loop iteration.", "", "        NEXTL [ level ]", "",
 "Allows to continue with the next loop iteration without executing the rest",
 "of the loop body.",
 "Execution continues just before the end clause of a DO, FOR, WHILE, or",
 "REPEAT block, where \"level\" indicates how many nested blocks to skip.",
 "The default value level=1 skips to the end of the innermost loop construct."
 };
static KmCommand _MACRO_SYNTAX_Looping_NEXTL = {  (KmCommand*)0,
 "/MACRO/SYNTAX/Looping/NEXTL", "NEXTL", 0, 3, 0, 0, (KmParameter**)0, 0, 0,
 (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 9,
 _MACRO_SYNTAX_Looping_NEXTL_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Looping_BREAKL_guidance[] = { "Terminate a loop.",
 "", "        BREAKL [ level ]", "",
 "Allows to terminate a loop prematurely. The BREAKL continues executing\
 after",
 "the end clause of a DO, FOR, WHILE, or REPEAT block, where \"level\"",
 "indicates how many nested constructs to terminate.  The default value\
 level=1", "terminates the innermost loop construct." };
static KmCommand _MACRO_SYNTAX_Looping_BREAKL = {
 &_MACRO_SYNTAX_Looping_NEXTL, "/MACRO/SYNTAX/Looping/BREAKL", "BREAKL", 0, 3,
 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 8, _MACRO_SYNTAX_Looping_BREAKL_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Looping_WHILE_guidance[] = {
 "Loop while condition is true.", "", "        WHILE expression DO",
 "           statements", "        ENDWHILE", "",
 "The WHILE-loop is iterated while the boolean expression evaluates to true.\
 The",
 "loop body is not executed at all if the boolean expression is false already\
 in", "the beginning." };
static KmCommand _MACRO_SYNTAX_Looping_WHILE = {
 &_MACRO_SYNTAX_Looping_BREAKL, "/MACRO/SYNTAX/Looping/WHILE", "WHILE", 0, 3,
 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 9, _MACRO_SYNTAX_Looping_WHILE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Looping_REPEAT_guidance[] = {
 "Loop until condition becomes true.", "", "        REPEAT",
 "           statements", "        UNTIL expression", "",
 "The body of a REPEAT-loop is executed at least once and iterated until the",
 "boolean expression evaluates to true." };
static KmCommand _MACRO_SYNTAX_Looping_REPEAT = {
 &_MACRO_SYNTAX_Looping_WHILE, "/MACRO/SYNTAX/Looping/REPEAT", "REPEAT", 0, 3,
 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 8, _MACRO_SYNTAX_Looping_REPEAT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Looping_FOR_guidance[] = {
 "Loop over items in an expression list.", "",
 "        FOR name IN expr_1 [ expr_2 ... expr_n ]", "           statements",
 "        ENDFOR", "",
 "In a FOR-loop the number of iterations is determined by the number of items\
 in",
 "the blank-separated expression list. The expression list must not be empty.\
 One",
 "by one each expression evaluated and assigned to the variable name before\
 the", "statements are executed.", "",
 "The expressions can be of any type: arithmetic, string, or garbage\
 expressions,",
 "and they do not need to be all of the same type. In general each expression\
 is", "a single list item even if the result contains blanks.", "",
 "The variable [*] is treated as a special case being equivalent to the",
 "expression list \"[1] [2] ... [n]\" which allows yet another construct to",
 "traverse the macro arguments:", "", "        FOR arg IN [*]",
 "           ...", "        ENDFOR" };
static KmCommand _MACRO_SYNTAX_Looping_FOR = { &_MACRO_SYNTAX_Looping_REPEAT,
 "/MACRO/SYNTAX/Looping/FOR", "FOR", 0, 3, 0, 0, (KmParameter**)0, 0, 0,
 (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 22,
 _MACRO_SYNTAX_Looping_FOR_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Looping_DO_guidance[] = {
 "Loop incrementing a loop counter.", "",
 "        DO loop = start_expr, finish_expr  [, step_expr ]",
 "           statements", "        ENDDO", "",
 "The step size (setp_expr) defaults to \"1\". The arithmetic expressions\
 involved",
 "can be floating point values but care must be taken of rounding errors.",
 "",
 "Note that \"DO i=1,0\" results in zero iterations and that the expressions\
 are", "evaluated only once." };
static KmCommand _MACRO_SYNTAX_Looping_DO = { &_MACRO_SYNTAX_Looping_FOR,
 "/MACRO/SYNTAX/Looping/DO", "DO", 0, 3, 0, 0, (KmParameter**)0, 0, 0,
 (SUBROUTINE*)0, (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 11,
 _MACRO_SYNTAX_Looping_DO_guidance, 0, (char**)0, 0, (char**)0, 0, (char**)0,
 (char*)0, (int*)0 };

static char *_MACRO_SYNTAX_Looping_guidance[] = {
 "Macro statements for construction loops." };
static KmMenu _MACRO_SYNTAX_Looping = {  (KmMenu*)0,  (KmMenu*)0,
 "/MACRO/SYNTAX/Looping", "Looping", 3, &_MACRO_SYNTAX_Looping_DO, 1,
 _MACRO_SYNTAX_Looping_guidance, 0, (char**)0, 0, (char**)0 };

static char *_MACRO_SYNTAX_Branching_guidance[] = {
 "Macro statements for general flow control." };
static KmMenu _MACRO_SYNTAX_Branching = { &_MACRO_SYNTAX_Looping,  (KmMenu*)0,
 "/MACRO/SYNTAX/Branching", "Branching", 3, &_MACRO_SYNTAX_Branching_CASE, 1,
 _MACRO_SYNTAX_Branching_guidance, 0, (char**)0, 0, (char**)0 };

static char *_MACRO_SYNTAX_Definitions_guidance[] = {
 "Statements for defining macros." };
static KmMenu _MACRO_SYNTAX_Definitions = { &_MACRO_SYNTAX_Branching, 
 (KmMenu*)0, "/MACRO/SYNTAX/Definitions", "Definitions", 3,
 &_MACRO_SYNTAX_Definitions_MACRO, 1, _MACRO_SYNTAX_Definitions_guidance, 0,
 (char**)0, 0, (char**)0 };

static char *_MACRO_SYNTAX_Variables_guidance[] = {
 "Explanation of KUIP macro variables.", "",
 "Macro variables do not have to be declared. They become defined by an",
 "assignment statement,", "", "        name = expression", "",
 "The right-hand side of the assignment can be an arithmetic expression, a\
 string",
 "expression, or a garbage expression (see MACRO/SYNTAX/Expressions). The",
 "expression is evaluated and the result is stored as a string (even for",
 "arithmetic expressions).", "",
 "A variable value can be used in other expressions or in command lines by",
 "enclosing the name in square brackets, [name]. If the name enclosed in\
 brackets", "is not a macro variable then no substitution takes place." };
static char *_MACRO_SYNTAX_Variables_keyword[] = { "assign", "assignment" };
static KmMenu _MACRO_SYNTAX_Variables = { &_MACRO_SYNTAX_Definitions, 
 (KmMenu*)0, "/MACRO/SYNTAX/Variables", "Variables", 3,
 &_MACRO_SYNTAX_Variables_Numbered, 15, _MACRO_SYNTAX_Variables_guidance, 2,
 _MACRO_SYNTAX_Variables_keyword, 0, (char**)0 };

static char *_MACRO_SYNTAX_Expressions_guidance[] = {
 "Explanation of KUIP expression syntax.", "",
 "KUIP has a built-in parser for different kinds of expressions: arithmetic",
 "expressions, boolean expressions, string expressions, and \"garbage",
 "expressions\"." };
static char *_MACRO_SYNTAX_Expressions_keyword[] = { "parser" };
static KmMenu _MACRO_SYNTAX_Expressions = { &_MACRO_SYNTAX_Variables, 
 (KmMenu*)0, "/MACRO/SYNTAX/Expressions", "Expressions", 3,
 &_MACRO_SYNTAX_Expressions_Arithmetic, 5, _MACRO_SYNTAX_Expressions_guidance,
 1, _MACRO_SYNTAX_Expressions_keyword, 0, (char**)0 };

static char *_MACRO_SYNTAX_guidance[] = {
 "Explanation of KUIP macro language and syntax.", "",
 "A macro is a set of command lines stored in a file, which can be created\
 and", "modified with any text editor.", "",
 "In addition to all available KUIP commands the  special \"macro\
 statements\"",
 "listed below are valid only inside macros. Note that the statement keywords\
 are", "fixed. Aliasing such as \"ALIAS/CREATE jump GOTO\" is not allowed." };
static char *_MACRO_SYNTAX_keyword[] = { "statement" };
static KmMenu _MACRO_SYNTAX = {  (KmMenu*)0, &_MACRO_SYNTAX_Expressions,
 "/MACRO/SYNTAX", "SYNTAX", 2,  (KmCommand*)0, 8, _MACRO_SYNTAX_guidance, 1,
 _MACRO_SYNTAX_keyword, 0, (char**)0 };

static char *_MACRO_GLOBAL_guidance[] = { "Operations on global variables." };
static KmMenu _MACRO_GLOBAL = { &_MACRO_SYNTAX,  (KmMenu*)0, "/MACRO/GLOBAL",
 "GLOBAL", 2, &_MACRO_GLOBAL_CREATE, 1, _MACRO_GLOBAL_guidance, 0, (char**)0,
 0, (char**)0 };

static char *_MACRO_DATA_guidance[] = {
 "Application command to store immediate data into a file.", "Example:",
 " Application DATA vec.dat", " 1  2  3", " 4  5  6", " 7  8  9", " vec.dat",
 " vec/read x,y,z vec.dat" };
static char *_MACRO_DATA_keyword[] = { "Application", "file" };
static KmCommand _MACRO_DATA = {  (KmCommand*)0, "/MACRO/DATA", "DATA", 0, 1,
 0, 0, (KmParameter**)0, 0, 0, (SUBROUTINE*)0, kxmdata, (SUBROUTINE*)0,
 (pCharFunc*)0, 8, _MACRO_DATA_guidance, 2, _MACRO_DATA_keyword, 0, (char**)0,
 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _MACRO_DEFAULTS_PATH = { "PATH", 4,
 "Search path for macro files", "?", (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static char *_MACRO_DEFAULTS_OPTION_range[] = { "?", "Command", "C", "Auto",
 "A", "AutoReverse", "AR" };
static char *_MACRO_DEFAULTS_OPTION_text[] = { "show current setting",
 "search for commands only", "same as 'Command'",
 "search for commands before macros", "same as 'Auto'",
 "search for macros before commands", "same as 'AutoReverse'" };
static KmParOption _MACRO_DEFAULTS_OPTION_type = {
 _MACRO_DEFAULTS_OPTION_text, (int*)0, (int*)0 };
static KmParameter _MACRO_DEFAULTS_OPTION = { "OPTION", 6, "Automatic EXEC",
 "?", (char*)0, 8, 7, _MACRO_DEFAULTS_OPTION_range, 7,
 _MACRO_DEFAULTS_OPTION_range, (KmParFlag)0, KmTYPE_OPTION,
 &_MACRO_DEFAULTS_OPTION_type };
static KmParameter *_MACRO_DEFAULTS_parameters[] = { &_MACRO_DEFAULTS_PATH,
 &_MACRO_DEFAULTS_OPTION };
static char *_MACRO_DEFAULTS_guidance[] = {
 "Set or show MACRO search attributes.", "", "On Unix and VMS systems",
 "PATH defines a comma separated list of directories in which the commands",
 "KUIP/EDIT, MACRO/EXEC, and MACRO/LIST search for macro files.",
 "For example,", " MACRO/DEFAULT '.,macro,~/macro'          | Unix",
 " MACRO/DEFAULT '[],[.macro],[macro]'      | VMS",
 "defines to search files first in the current directory,",
 "then in the subdirectory 'macro' of the current directory,",
 "and last the subdirectory 'macro' of the home directory.", "",
 "On VM/CMS system PATH defines a comma separated list of filemodes.", "E.g.",
 " MACRO/DEFAULT '*'       | search all disks",
 " MACRO/DEFAULT 'A,C'     | search only disks A and C", "",
 "If PATH='?' the currently defined search path is shown.",
 "If PATH='.' the search path is undefined, i.e. files are search for",
 "in the current directory (A-disk on VM/CMS) only.",
 "The startup value is PATH='.'.", "",
 "The search path is not applied if the file specification already",
 "contains an explicit directory path or if it starts with a '-'",
 "character (which is stripped off).", "",
 "OPTION allows to define whether macros can be invoked by their name only",
 "without prepending the KUIP/EXEC command:", " DEFAULT -Command",
 " CMD                     | CMD must be a command", " DEFAULT -Auto",
 " CMD                     | if CMD is not a command try EXEC CMD",
 " DEFAULT -AutoReverse",
 " CMD                     | try EXEC CMD first; if not found try command\
 CMD", "The startup value is 'Command' (also reset by PATH='.').", "",
 "Important note:", "",
 "Inside macros the DEFAULT -A (or -AR) logic is disabled, i.e.",
 "DEFAULT -C is always assumed." };
static KmCommand _MACRO_DEFAULTS = { &_MACRO_DATA, "/MACRO/DEFAULTS",
 "DEFAULTS", 0, 1, 2, 0, _MACRO_DEFAULTS_parameters, 0, 0, (SUBROUTINE*)0,
 kxmdefaults, (SUBROUTINE*)0, (pCharFunc*)0, 40, _MACRO_DEFAULTS_guidance, 0,
 (char**)0, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_MACRO_TRACE_OPTION_range[] = { "ON", "OFF" };
static char *_MACRO_TRACE_OPTION_text[] = { (char*)0, (char*)0 };
static KmParOption _MACRO_TRACE_OPTION_type = { _MACRO_TRACE_OPTION_text,
 (int*)0, (int*)0 };
static KmParameter _MACRO_TRACE_OPTION = { "OPTION", 6, "Option", "ON",
 (char*)0, 8, 2, _MACRO_TRACE_OPTION_range, 2, _MACRO_TRACE_OPTION_range,
 (KmParFlag)0, KmTYPE_OPTION, &_MACRO_TRACE_OPTION_type };
static char *_MACRO_TRACE_LEVEL_range[] = { "", "TEST", "WAIT", "FULL",
 "DEBUG" };
static char *_MACRO_TRACE_LEVEL_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0, (char*)0 };
static KmParOption _MACRO_TRACE_LEVEL_type = { _MACRO_TRACE_LEVEL_text,
 (int*)0, (int*)0 };
static KmParameter _MACRO_TRACE_LEVEL = { "LEVEL", 5, "Level", " ", (char*)0,
 8, 5, _MACRO_TRACE_LEVEL_range, 5, _MACRO_TRACE_LEVEL_range, (KmParFlag)0,
 KmTYPE_OPTION, &_MACRO_TRACE_LEVEL_type };
static KmParameter *_MACRO_TRACE_parameters[] = { &_MACRO_TRACE_OPTION,
 &_MACRO_TRACE_LEVEL };
static char *_MACRO_TRACE_guidance[] = {
 "Set ON/OFF the trace of commands during macro execution.",
 "If TRACE='ON' the next command is written on the terminal",
 "before being executed.",
 "If LEVEL='TEST' the command is only echoed but not executed.",
 "If LEVEL='WAIT' the command WAIT is automatically inserted",
 "after the execution of each command.",
 "The startup values are OPTION='OFF' and LEVEL=' '." };
static char *_MACRO_TRACE_keyword[] = { "DEBUG" };
static KmCommand _MACRO_TRACE = { &_MACRO_DEFAULTS, "/MACRO/TRACE", "TRACE",
 0, 1, 2, 0, _MACRO_TRACE_parameters, 0, 0, (SUBROUTINE*)0, kxmtrace,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _MACRO_TRACE_guidance, 1,
 _MACRO_TRACE_keyword, 0, (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _MACRO_LIST_MNAME = { "MNAME", 5, "Macro name pattern",
 " ", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_MACRO_LIST_parameters[] = { &_MACRO_LIST_MNAME };
static char *_MACRO_LIST_guidance[] = {
 "List all macros in the search path defined by MACRO/DEFAULTS.",
 "Macros are files with the extension KUMAC.",
 "MNAME may be specified to restrict the list to the macros",
 "containing such a string in the first part of their name.", "For example,",
 " MACRO/LIST ABC", "will list only macros starting with ABC." };
static KmCommand _MACRO_LIST = { &_MACRO_TRACE, "/MACRO/LIST", "LIST", 0, 1,
 1, 0, _MACRO_LIST_parameters, 0, 0, (SUBROUTINE*)0, kxmlist, (SUBROUTINE*)0,
 (pCharFunc*)0, 7, _MACRO_LIST_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _MACRO_EXEC_MNAME = { "MNAME", 5, "Macro name", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter _MACRO_EXEC_MARGS = { "MARGS", 5, "Macro arguments", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)64, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_MACRO_EXEC_parameters[] = { &_MACRO_EXEC_MNAME,
 &_MACRO_EXEC_MARGS };
static char *_MACRO_EXEC_guidance[] = {
 "Execute the command lines contained in the macro MNAME.",
 "As a file can contain several macros, the character '#' is",
 "used to select a particular macro inside a file as explained below.", "",
 "If MNAME does not contain the character '#', the file MNAME.KUMAC",
 "is searched and the first macro is executed (it may be an unnamed",
 "macro if a MACRO statement is not found as first command line in the\
 file).", "",
 "If MNAME is of the form FILE#MACRO, the file named FILE.KUMAC is searched",
 "and the macro named MACRO is executed.", "", "Examples:",
 " EXEC ABC   to exec first (or unnamed) macro of file ABC.KUMAC",
 " EXEC ABC#M to exec macro M of file ABC.KUMAC", "",
 "The command MACRO/DEFAULTS can be used to define a directory search path",
 "for macro files." };
static KmCommand _MACRO_EXEC = { &_MACRO_LIST, "/MACRO/EXEC", "EXEC", 0, 1, 2,
 1, _MACRO_EXEC_parameters, 0, 0, (SUBROUTINE*)0, kxmexec, (SUBROUTINE*)0,
 (pCharFunc*)0, 17, _MACRO_EXEC_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static char *_MACRO_guidance[] = { "Macro Processor commands." };
static KmMenu _MACRO = {  (KmMenu*)0, &_MACRO_GLOBAL, "/MACRO", "MACRO", 1,
 &_MACRO_EXEC, 1, _MACRO_guidance, 0, (char**)0, 0, (char**)0 };

  klnkmenu( &_MACRO, 950303 );
}


#ifdef F77_LCASE
#  define vecdef_ vecdef
#  define kxvope_ kxvope
#  define kxwriv_ kxwriv
#  define kxreav_ kxreav
#  define kxcopv_ kxcopv
#  define kxdelv_ kxdelv
#  define kxlisv_ kxlisv
#endif

#ifdef F77_UCASE
#  define vecdef_ VECDEF
#  define kxvope_ KXVOPE
#  define kxwriv_ KXWRIV
#  define kxreav_ KXREAV
#  define kxcopv_ KXCOPV
#  define kxdelv_ KXDELV
#  define kxlisv_ KXLISV
#endif

#ifdef IBM370
#  pragma linkage(VECDEF,FORTRAN)
#  pragma linkage(KXVOPE,FORTRAN)
#  pragma linkage(KXWRIV,FORTRAN)
#  pragma linkage(KXREAV,FORTRAN)
#  pragma linkage(KXCOPV,FORTRAN)
#  pragma linkage(KXDELV,FORTRAN)
#  pragma linkage(KXLISV,FORTRAN)
#endif

extern void vecdef_();
extern void kxvope_();
extern void kxwriv_();
extern void kxreav_();
extern void kxcopv_();
extern void kxdelv_();
extern void kxlisv_();

extern int kxvprint();
extern int kxvinput();
extern int kxvcreate();

void vecdef_()
{

static KmParameter _VECTOR_OPERATIONS_VDIVIDE_VNAM1 = { "VNAM1", 5,
 "First source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VDIVIDE_VNAM2 = { "VNAM2", 5,
 "Second source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VDIVIDE_VNAM3 = { "VNAM3", 5,
 "Destination vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_OPERATIONS_VDIVIDE_parameters[] = {
 &_VECTOR_OPERATIONS_VDIVIDE_VNAM1, &_VECTOR_OPERATIONS_VDIVIDE_VNAM2,
 &_VECTOR_OPERATIONS_VDIVIDE_VNAM3 };
static char *_VECTOR_OPERATIONS_VDIVIDE_guidance[] = {
 "VNAM3(I) = VNAM1(I) / VNAM2(I)     ( or 0 if VNAM2(I)=0 )" };
static char *_VECTOR_OPERATIONS_VDIVIDE_keyword[] = { "DIVIDE" };
static KmCommand _VECTOR_OPERATIONS_VDIVIDE = {  (KmCommand*)0,
 "/VECTOR/OPERATIONS/VDIVIDE", "VDIVIDE", 0, 2, 3, 3,
 _VECTOR_OPERATIONS_VDIVIDE_parameters, 0, 0, kxvope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _VECTOR_OPERATIONS_VDIVIDE_guidance, 1,
 _VECTOR_OPERATIONS_VDIVIDE_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _VECTOR_OPERATIONS_VSUBTRACT_VNAM1 = { "VNAM1", 5,
 "First source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VSUBTRACT_VNAM2 = { "VNAM2", 5,
 "Second source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VSUBTRACT_VNAM3 = { "VNAM3", 5,
 "Destination vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_OPERATIONS_VSUBTRACT_parameters[] = {
 &_VECTOR_OPERATIONS_VSUBTRACT_VNAM1, &_VECTOR_OPERATIONS_VSUBTRACT_VNAM2,
 &_VECTOR_OPERATIONS_VSUBTRACT_VNAM3 };
static char *_VECTOR_OPERATIONS_VSUBTRACT_guidance[] = {
 "VNAM3(I) = VNAM1(I) - VNAM2(I)" };
static char *_VECTOR_OPERATIONS_VSUBTRACT_keyword[] = { "SUBTRACT" };
static KmCommand _VECTOR_OPERATIONS_VSUBTRACT = { &_VECTOR_OPERATIONS_VDIVIDE,
 "/VECTOR/OPERATIONS/VSUBTRACT", "VSUBTRACT", 0, 2, 3, 3,
 _VECTOR_OPERATIONS_VSUBTRACT_parameters, 0, 0, kxvope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _VECTOR_OPERATIONS_VSUBTRACT_guidance, 1,
 _VECTOR_OPERATIONS_VSUBTRACT_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _VECTOR_OPERATIONS_VMULTIPLY_VNAM1 = { "VNAM1", 5,
 "First source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VMULTIPLY_VNAM2 = { "VNAM2", 5,
 "Second source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VMULTIPLY_VNAM3 = { "VNAM3", 5,
 "Destination vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_OPERATIONS_VMULTIPLY_parameters[] = {
 &_VECTOR_OPERATIONS_VMULTIPLY_VNAM1, &_VECTOR_OPERATIONS_VMULTIPLY_VNAM2,
 &_VECTOR_OPERATIONS_VMULTIPLY_VNAM3 };
static char *_VECTOR_OPERATIONS_VMULTIPLY_guidance[] = {
 "VNAM3(I) = VNAM1(I) * VNAM2(I)" };
static char *_VECTOR_OPERATIONS_VMULTIPLY_keyword[] = { "MULTIPLY" };
static KmCommand _VECTOR_OPERATIONS_VMULTIPLY = {
 &_VECTOR_OPERATIONS_VSUBTRACT, "/VECTOR/OPERATIONS/VMULTIPLY", "VMULTIPLY",
 0, 2, 3, 3, _VECTOR_OPERATIONS_VMULTIPLY_parameters, 0, 0, kxvope_,
 (IntFunc*)0, (SUBROUTINE*)0, (pCharFunc*)0, 1,
 _VECTOR_OPERATIONS_VMULTIPLY_guidance, 1,
 _VECTOR_OPERATIONS_VMULTIPLY_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _VECTOR_OPERATIONS_VADD_VNAM1 = { "VNAM1", 5,
 "First source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VADD_VNAM2 = { "VNAM2", 5,
 "Second source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_OPERATIONS_VADD_VNAM3 = { "VNAM3", 5,
 "Destination vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_OPERATIONS_VADD_parameters[] = {
 &_VECTOR_OPERATIONS_VADD_VNAM1, &_VECTOR_OPERATIONS_VADD_VNAM2,
 &_VECTOR_OPERATIONS_VADD_VNAM3 };
static char *_VECTOR_OPERATIONS_VADD_guidance[] = {
 "VNAM3(I) = VNAM1(I) + VNAM2(I)" };
static char *_VECTOR_OPERATIONS_VADD_keyword[] = { "ADD" };
static KmCommand _VECTOR_OPERATIONS_VADD = { &_VECTOR_OPERATIONS_VMULTIPLY,
 "/VECTOR/OPERATIONS/VADD", "VADD", 0, 2, 3, 3,
 _VECTOR_OPERATIONS_VADD_parameters, 0, 0, kxvope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _VECTOR_OPERATIONS_VADD_guidance, 1,
 _VECTOR_OPERATIONS_VADD_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _VECTOR_OPERATIONS_VSCALE_VNAM1 = { "VNAM1", 5,
 "Source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _VECTOR_OPERATIONS_VSCALE_SCALE_type = { (char*)0,
 (char*)0, (char*)0, (char*)0, 0 };
static KmParameter _VECTOR_OPERATIONS_VSCALE_SCALE = { "SCALE", 5,
 "Scale factor", (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_REAL, &_VECTOR_OPERATIONS_VSCALE_SCALE_type };
static KmParameter _VECTOR_OPERATIONS_VSCALE_VNAM2 = { "VNAM2", 5,
 "Destination vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_OPERATIONS_VSCALE_parameters[] = {
 &_VECTOR_OPERATIONS_VSCALE_VNAM1, &_VECTOR_OPERATIONS_VSCALE_SCALE,
 &_VECTOR_OPERATIONS_VSCALE_VNAM2 };
static char *_VECTOR_OPERATIONS_VSCALE_guidance[] = {
 "VNAM2(I) = SCALE    * VNAM1(I)" };
static char *_VECTOR_OPERATIONS_VSCALE_keyword[] = { "SCALE" };
static KmCommand _VECTOR_OPERATIONS_VSCALE = { &_VECTOR_OPERATIONS_VADD,
 "/VECTOR/OPERATIONS/VSCALE", "VSCALE", 0, 2, 3, 3,
 _VECTOR_OPERATIONS_VSCALE_parameters, 0, 0, kxvope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _VECTOR_OPERATIONS_VSCALE_guidance, 1,
 _VECTOR_OPERATIONS_VSCALE_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static KmParameter _VECTOR_OPERATIONS_VBIAS_VNAM1 = { "VNAM1", 5,
 "Source vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0,
 (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParReal   _VECTOR_OPERATIONS_VBIAS_BIAS_type = { (char*)0, (char*)0,
 (char*)0, (char*)0, 0 };
static KmParameter _VECTOR_OPERATIONS_VBIAS_BIAS = { "BIAS", 4, "Bias value",
 (char*)0, (char*)0, 12, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_REAL, &_VECTOR_OPERATIONS_VBIAS_BIAS_type };
static KmParameter _VECTOR_OPERATIONS_VBIAS_VNAM2 = { "VNAM2", 5,
 "Destination vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_OPERATIONS_VBIAS_parameters[] = {
 &_VECTOR_OPERATIONS_VBIAS_VNAM1, &_VECTOR_OPERATIONS_VBIAS_BIAS,
 &_VECTOR_OPERATIONS_VBIAS_VNAM2 };
static char *_VECTOR_OPERATIONS_VBIAS_guidance[] = {
 "VNAM2(I) = BIAS     + VNAM1(I)" };
static char *_VECTOR_OPERATIONS_VBIAS_keyword[] = { "BIAS" };
static KmCommand _VECTOR_OPERATIONS_VBIAS = { &_VECTOR_OPERATIONS_VSCALE,
 "/VECTOR/OPERATIONS/VBIAS", "VBIAS", 0, 2, 3, 3,
 _VECTOR_OPERATIONS_VBIAS_parameters, 0, 0, kxvope_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 1, _VECTOR_OPERATIONS_VBIAS_guidance, 1,
 _VECTOR_OPERATIONS_VBIAS_keyword, 0, (char**)0, 0, (char**)0, (char*)0,
 (int*)0 };

static char *_VECTOR_OPERATIONS_guidance[] = {
 "Simple arithmetic operations between vectors.",
 "In all the operations only the minimum vector length is considered,",
 "i.e. an operation between a vector A of dimension 10 and a vector B",
 "of dimension 5 will involve the first 5 elements in both vectors.",
 "If the destination vector does not exist,",
 "it is created with the same length as the source vector." };
static KmMenu _VECTOR_OPERATIONS = {  (KmMenu*)0,  (KmMenu*)0,
 "/VECTOR/OPERATIONS", "OPERATIONS", 2, &_VECTOR_OPERATIONS_VBIAS, 6,
 _VECTOR_OPERATIONS_guidance, 0, (char**)0, 0, (char**)0 };

static KmParameter _VECTOR_WRITE_VLIST = { "VLIST", 5, "Vector list",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_WRITE_FNAME = { "FNAME", 5, "File name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter _VECTOR_WRITE_FORMAT = { "FORMAT", 6, "Format",
 "5(1X,G13.7)", (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_VECTOR_WRITE_CHOPT_range[] = { "OC", "O", " ", "C" };
static char *_VECTOR_WRITE_CHOPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _VECTOR_WRITE_CHOPT_type = { _VECTOR_WRITE_CHOPT_text,
 (int*)0, (int*)0 };
static KmParameter _VECTOR_WRITE_CHOPT = { "CHOPT", 5, "Options", "OC",
 (char*)0, 8, 4, _VECTOR_WRITE_CHOPT_range, 4, _VECTOR_WRITE_CHOPT_range,
 (KmParFlag)0, KmTYPE_OPTION, &_VECTOR_WRITE_CHOPT_type };
static KmParameter *_VECTOR_WRITE_parameters[] = { &_VECTOR_WRITE_VLIST,
 &_VECTOR_WRITE_FNAME, &_VECTOR_WRITE_FORMAT, &_VECTOR_WRITE_CHOPT };
static char *_VECTOR_WRITE_guidance[] = {
 "Write to a file the content of vector(s).",
 "If FNAME=' ' the content is written to the terminal.",
 "A format can be specified, e.g. FORMAT='F10.5,2X,F10.5',",
 "or the default one is used if FORMAT is not supplied.", "",
 "Vectors in the list VLIST are separated by a comma and",
 "embedded blanks are not allowed. If subscripts are present",
 "in vector names, the smallest one is taken.", "",
 "CHOPT is used to select between the following options:",
 " 'OC'   file is Opened, written and then Closed (default case)",
 " 'O'    file is Opened and then written (left open for further writing)",
 " ' '    file is written (already open, left so for further writing)",
 " 'C'    file is written and then Closed (already open)",
 "Enter HELP VECTOR for more information on vector addressing." };
static KmCommand _VECTOR_WRITE = {  (KmCommand*)0, "/VECTOR/WRITE", "WRITE",
 0, 1, 4, 1, _VECTOR_WRITE_parameters, 0, 0, kxwriv_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 15, _VECTOR_WRITE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_READ_VLIST = { "VLIST", 5, "Vector list", (char*)0,
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter _VECTOR_READ_FNAME = { "FNAME", 5, "File name", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter _VECTOR_READ_FORMAT = { "FORMAT", 6, "Format", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static char *_VECTOR_READ_OPT_range[] = { "OC", "O", " ", "C" };
static char *_VECTOR_READ_OPT_text[] = { (char*)0, (char*)0, (char*)0,
 (char*)0 };
static KmParOption _VECTOR_READ_OPT_type = { _VECTOR_READ_OPT_text, (int*)0,
 (int*)0 };
static KmParameter _VECTOR_READ_OPT = { "OPT", 3, "Options", "OC", (char*)0,
 8, 4, _VECTOR_READ_OPT_range, 4, _VECTOR_READ_OPT_range, (KmParFlag)0,
 KmTYPE_OPTION, &_VECTOR_READ_OPT_type };
static KmParameter _VECTOR_READ_MATCH = { "MATCH", 5, "Matching pattern", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_VECTOR_READ_parameters[] = { &_VECTOR_READ_VLIST,
 &_VECTOR_READ_FNAME, &_VECTOR_READ_FORMAT, &_VECTOR_READ_OPT,
 &_VECTOR_READ_MATCH };
static char *_VECTOR_READ_guidance[] = {
 "Enter values into vector(s) from a file.",
 "A format can be specified, e.g. FORMAT='F10.5,2X,F10.5',",
 "or the free format is used if FORMAT is not supplied.", "",
 "If vector(s) are not existing they will be created",
 "of the size as read from the file.", "",
 "Vectors in the list VLIST are separated by a comma and",
 "embedded blanks are not allowed. If subscripts are present",
 "in vector names, the smallest one is taken.", "",
 "OPT is used to select between the following options:",
 " 'OC'   file is Opened, read and then Closed (default case)",
 " 'O'    file is Opened and then read (left open for further reading)",
 " ' '    file is read (already open, left so for further reading)",
 " 'C'    file is read and then Closed (already open)",
 "If the character 'Z' is present in OPT, the vector elements equal to zero",
 "after reading are set to the latest non-zero element value",
 "(for example reading 1 2 3 0 0 4 0 5 will give 1 2 3 3 3 4 4 5).", "",
 "MATCH is used to specify a pattern string, restricting",
 "the vector filling only to the records in the file which",
 "verify the pattern. Example of patterns:",
 "  /string/      match a string (starting in column 1)",
 " -/string/      do not match a string (starting in column 1)",
 "  /string/(n)   match a string, starting in column n",
 "  /string/(*)   match a string, starting at any column",
 "Enter HELP VECTOR for more information on vector addressing." };
static KmCommand _VECTOR_READ = { &_VECTOR_WRITE, "/VECTOR/READ", "READ", 0,
 1, 5, 2, _VECTOR_READ_parameters, 0, 0, kxreav_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 28, _VECTOR_READ_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_PRINT_VNAME = { "VNAME", 5, "Vector name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_VECTOR_PRINT_DENSE_range[] = { "0", "1", "2" };
static KmParInt    _VECTOR_PRINT_DENSE_type = { (char*)0, (char*)0, (char*)0,
 (char*)0, 0 };
static KmParameter _VECTOR_PRINT_DENSE = { "DENSE", 5, "Output density", "1",
 (char*)0, 8, 3, _VECTOR_PRINT_DENSE_range, 3, _VECTOR_PRINT_DENSE_range,
 (KmParFlag)0, KmTYPE_INT, &_VECTOR_PRINT_DENSE_type };
static KmParameter *_VECTOR_PRINT_parameters[] = { &_VECTOR_PRINT_VNAME,
 &_VECTOR_PRINT_DENSE };
static char *_VECTOR_PRINT_guidance[] = {
 "Write to the terminal the content of a vector.",
 "Enter HELP VECTOR for more information on vector addressing.", "",
 "If DENSE.EQ.0 the output is one vector element per line.",
 "If DENSE.EQ.1 the output for a sequence of identical vector elements",
 "is compressed to two lines stating the start and end indices.",
 "If DENSE.EQ.2 the output for a sequence of identical vector elements",
 "is compressed to a single line." };
static KmCommand _VECTOR_PRINT = { &_VECTOR_READ, "/VECTOR/PRINT", "PRINT", 0,
 1, 2, 1, _VECTOR_PRINT_parameters, 0, 0, (SUBROUTINE*)0, kxvprint,
 (SUBROUTINE*)0, (pCharFunc*)0, 8, _VECTOR_PRINT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_INPUT_VNAME = { "VNAME", 5, "Vector name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_INPUT_VALUES = { "VALUES", 6, "Value list", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)72, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_VECTOR_INPUT_parameters[] = { &_VECTOR_INPUT_VNAME,
 &_VECTOR_INPUT_VALUES };
static char *_VECTOR_INPUT_guidance[] = {
 "Enter values into a vector from the terminal.", "Example:",
 " VEC/INPUT V(6:10) 1.1 2.22 3.333 4.4444 5.55555",
 "If many equal values have to be entered consecutively, one can specify\
 just",
 "one value and precede it by a repetition factor and an asterisk. Example:",
 " VEC/INPUT V 5*1 2 4*3   --->   VEC/INPUT V 1 1 1 1 1 2 3 3 3 3",
 "Enter HELP VECTOR for more information on vector addressing." };
static KmCommand _VECTOR_INPUT = { &_VECTOR_PRINT, "/VECTOR/INPUT", "INPUT",
 0, 1, 2, 1, _VECTOR_INPUT_parameters, 0, 0, (SUBROUTINE*)0, kxvinput,
 (SUBROUTINE*)0, (pCharFunc*)0, 7, _VECTOR_INPUT_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_COPY_VNAM1 = { "VNAM1", 5, "Source vector name",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static KmParameter _VECTOR_COPY_VNAM2 = { "VNAM2", 5,
 "Destination vector name", (char*)0, (char*)0, 20, 0, (char**)0, 0,
 (char**)0, (KmParFlag)0, KmTYPE_CHAR,  (void*)0 };
static KmParameter *_VECTOR_COPY_parameters[] = { &_VECTOR_COPY_VNAM1,
 &_VECTOR_COPY_VNAM2 };
static char *_VECTOR_COPY_guidance[] = { "Copy a vector into another one.",
 "Mixed vector type copy is supported (e.g. Integer ---> Real and\
 viceversa).",
 "If VNAM2 does not exist it is created with the required dimensions,",
 "not necessarily the same as the source vector if a sub-range was\
 specified.", "For example, if A is a 3 x 100 vector and B does not exist,",
 "COPY A(2,11:60) B will create B as a 50 elements mono-dimensional vector;",
 "a special (and non-standard with FORTRAN 77) notation is used such that,",
 "still using the above vectors, COPY A(2,1:100) B and COPY A(2) B have the",
 "same effect.", "",
 "Note that VECTOR/COPY does not allow a range for the destination vector",
 "not specifying consecutive elements (i.e. along the first dimension):",
 " VEC/COPY V(5)      W(3,4)     | O.K.",
 " VEC/COPY V1(2:3,5) V2(4:5,9)  | O.K.",
 " VEC/COPY V1(5,2:3) V2(4:5,9)  | O.K.",
 " VEC/COPY V1(3,3:4) V2(4,4:5)  | NOT allowed",
 " VEC/COPY V1(2:3,5) V2(2,4:5)  | NOT allowed",
 "Enter HELP VECTOR for more information on vector addressing." };
static KmCommand _VECTOR_COPY = { &_VECTOR_INPUT, "/VECTOR/COPY", "COPY", 0,
 1, 2, 2, _VECTOR_COPY_parameters, 0, 0, kxcopv_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 18, _VECTOR_COPY_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_DELETE_VLIST = { "VLIST", 5, "Vector list", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_VECTOR_DELETE_parameters[] = { &_VECTOR_DELETE_VLIST };
static char *_VECTOR_DELETE_guidance[] = {
 "Delete from memory all vectors in the list VLIST.",
 "The vectors are separated in the list by a comma and embedded blanks",
 "are not allowed. An asterisk at the end of VLIST acts as wild-card:",
 " VEC/DEL AB*          --->  deletes all vectors starting by AB",
 " VEC/DEL *            --->  deletes all vectors" };
static KmCommand _VECTOR_DELETE = { &_VECTOR_COPY, "/VECTOR/DELETE", "DELETE",
 0, 1, 1, 1, _VECTOR_DELETE_parameters, 1, 0, kxdelv_, (IntFunc*)0,
 (SUBROUTINE*)0, (pCharFunc*)0, 5, _VECTOR_DELETE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_VECTOR_LIST_guidance[] = {
 "List all vectors (name, dimensions, type)." };
static KmCommand _VECTOR_LIST = { &_VECTOR_DELETE, "/VECTOR/LIST", "LIST", 0,
 1, 0, 0, (KmParameter**)0, 0, 0, kxlisv_, (IntFunc*)0, (SUBROUTINE*)0,
 (pCharFunc*)0, 1, _VECTOR_LIST_guidance, 0, (char**)0, 0, (char**)0, 0,
 (char**)0, (char*)0, (int*)0 };

static KmParameter _VECTOR_CREATE_VNAME = { "VNAME", 5, "Vector name(length)",
 (char*)0, (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)0,
 KmTYPE_CHAR,  (void*)0 };
static char *_VECTOR_CREATE_TYPE_range[] = { "R", "I" };
static char *_VECTOR_CREATE_TYPE_text[] = { (char*)0, (char*)0 };
static KmParOption _VECTOR_CREATE_TYPE_type = { _VECTOR_CREATE_TYPE_text,
 (int*)0, (int*)0 };
static KmParameter _VECTOR_CREATE_TYPE = { "TYPE", 4, "Vector type", "R",
 (char*)0, 8, 2, _VECTOR_CREATE_TYPE_range, 2, _VECTOR_CREATE_TYPE_range,
 (KmParFlag)0, KmTYPE_OPTION, &_VECTOR_CREATE_TYPE_type };
static KmParameter _VECTOR_CREATE_VALUES = { "VALUES", 6, "Value list", " ",
 (char*)0, 20, 0, (char**)0, 0, (char**)0, (KmParFlag)72, KmTYPE_CHAR, 
 (void*)0 };
static KmParameter *_VECTOR_CREATE_parameters[] = { &_VECTOR_CREATE_VNAME,
 &_VECTOR_CREATE_TYPE, &_VECTOR_CREATE_VALUES };
static char *_VECTOR_CREATE_guidance[] = {
 "Create a vector named VNAME (elements are set to zero).",
 "The dimensions are taken from the name,",
 "for example VEC(20), VEC(3,100), VEC(2,2,10).",
 "Up to 3 dimensions are supported. Dimensions which are not specified",
 "are taken to 1, for example VEC(10) ---> VEC(10,1,1) and VEC --->\
 VEC(1,1,1).", "The vector may be of type Real or Integer.",
 "A vector is filled at the same time if parameters are given",
 "after the TYPE:", " VEC/CREATE V(10) R 1 2 3 4 5 66 77 88 99 111",
 " VEC/CREATE W(20) R 1 2 3",
 "In the last example only the first three elements are filled.",
 "Vector elements may be changed later with the command VECTOR/INPUT.", "",
 "If many equal values have to be entered consecutively, one can specify\
 just",
 "one value and precede it by a repetition factor and an asterisk. Example:",
 " VEC/CREATE Z(20) R 5*1 2 4*3   --->   VEC/CREATE Z(20) R 1 1 1 1 1 2 3 3 3\
 3", "Enter HELP VECTOR for more information on vector addressing." };
static KmCommand _VECTOR_CREATE = { &_VECTOR_LIST, "/VECTOR/CREATE", "CREATE",
 0, 1, 3, 1, _VECTOR_CREATE_parameters, 0, 0, (SUBROUTINE*)0, kxvcreate,
 (SUBROUTINE*)0, (pCharFunc*)0, 17, _VECTOR_CREATE_guidance, 0, (char**)0, 0,
 (char**)0, 0, (char**)0, (char*)0, (int*)0 };

static char *_VECTOR_guidance[] = { "Vector Processor commands.",
 "Vectors are equivalent to FORTRAN 77 arrays and they use",
 "the same notation except when omitting indexes (see last line below).",
 "Up to 3 dimensions are supported. Examples:",
 " Vec(20) (mono-dimensional with 20 elements)", "may be addressed by:",
 " Vec          for all elements", " Vec(13)      for element 13-th",
 " Vec(12:)     for elements 12-th to last",
 " Vec(:10)     for elements first to 10-th",
 " Vec(5:8)     for elements 5-th to 8-th", "",
 " Vec(3,100) (2-dimensional with 3 columns by 100 rows):",
 "may be addressed by:",
 " Vec(2,5:8)   for elements 5-th to 8-th in 2-nd column",
 " Vec(2:3,5:8) for elements 5-th to 8-th in 2-nd to 3-rd columns",
 " Vec(2,5)     for element 5-th in 2-nd column",
 " Vec(:,3)     for all elements in 3-rd row",
 " Vec(2)       for all elements in 2-nd column (SPECIAL CASE)",
 "The latest line shows the special (and non-standard with FORTRAN 77)",
 "notation such that missing indexes are substituted to the right.", "",
 "An 'invisible' vector called '?', mono-dimensional and of length 100,",
 "is always present. Is is used for communicating between user arrays",
 "and KUIP vectors, being equivalenced with the real array VECTOR(100)",
 "in the labeled common block /KCWORK/." };
static KmMenu _VECTOR = {  (KmMenu*)0, &_VECTOR_OPERATIONS, "/VECTOR",
 "VECTOR", 1, &_VECTOR_CREATE, 26, _VECTOR_guidance, 0, (char**)0, 0,
 (char**)0 };

  klnkmenu( &_VECTOR, 950303 );
}


