// Copyright (C) 2018, Guy Barrand. All rights reserved.
// See the file gopaw.license for terms.

#ifndef gopaw_function_manager
#define gopaw_function_manager

#include "ifunction"

#include "plugin_func"

#include <inlib/system>
#include <inlib/touplow>
#include <inlib/parse>
#include <inlib/strip>
#include <inlib/sys/plugin>

#include <list>

#ifdef APP_USE_PYTHON
#include <exlib/Python>
#endif

namespace gopaw {

class function_manager {
  typedef inlib::value imp_value_t;  //imp=implementation.
  typedef inlib::value itf_value_t;  //itf=interface.
  // if changing the two upper typedef, you have to change, in the below, appearences of the line :
  //%sbool gopaw_cpp_wrap_%s(...)
  //%sbool gopaw_f77_wrap_%s(...)
  //%sbool gopaw_py_wrap_%s(...)
public:
  function_manager(std::ostream& a_out,const std::string& a_res_dir,unsigned int a_verbose_level)
  :m_out(a_out)
  ,m_res_dir(a_res_dir)
  ,m_verbose_level(a_verbose_level)
  {}
  virtual ~function_manager(){
    // Delete in reverse order :
    std::list<gopaw::ifunction*>::iterator it;
    while(!fList.empty()) {
      it = fList.end();
      it--;
      gopaw::ifunction* entry  = *it;
      fList.erase(it);
      delete entry;      
    }
    safe_clear(m_plugins);
  }
protected:
  function_manager(const function_manager& a_from):m_out(a_from.m_out){}
  function_manager& operator=(const function_manager&) {return *this;}
public:
  gopaw::ifunction* find_function(const std::string& a_file,const std::string& a_model) {
    // Already loaded ?
    gopaw::ifunction* func = _find_function(a_model);
    if(!func) {
      std::string s = a_model;
      inlib::touppercase(s);
      func = _find_function(s);
    }
    if(m_verbose_level) {
      if(func) {
        m_out << "gopaw::function_manager::find_function : " << inlib::sout(a_model) << " found." << std::endl;
      } else {
        m_out << "gopaw::function_manager::find_function :"
              << " " << inlib::sout(a_model) << " not found, try to load file " << inlib::sout(a_file) << " ..."
              << std::endl;
      }
    }
    if(func) return func;
    if(a_file.size()) { //Not found. Load the file :
      if(!load_file(a_file)) return 0;
      func = _find_function(a_model);
      if(!func) {
        std::string s = a_model;
        inlib::touppercase(s);
        func = _find_function(s);
      }
    }
    if(m_verbose_level) {
      if(func) {
        m_out << "gopaw::function_manager::find_function : " << inlib::sout(a_model) << " found." << std::endl;
      } else {
        m_out << "gopaw::function_manager::find_function : " << inlib::sout(a_model) << " not found." << std::endl;
      }
    }
    return func;
  }
  
  bool load_file(const std::string& a_file) {
    std::ostream& out = m_out;
    
    if(!set_env()) {
      out << "function_manager::load_file : set_env failed." << std::endl;
      return false;
    }

    std::string GOPAWROOT;
    if(!inlib::get_env("GOPAWROOT",GOPAWROOT)) {
      out << "function_manager::load_file : Environment variable GOPAWROOT not defined." << std::endl;
      return false;
    }
    if(!inlib::isenv("INLIBROOT")) {
      out << "function_manager::load_file : Environment variable INLIBROOT not defined." << std::endl;
      return false;
    }
  
    if(m_verbose_level) {
      out << "gopaw::function_manager::load_file : " << inlib::sout(a_file) << " ..." << std::endl;
    }
    
    std::string builder;
  
    if(inlib::is_f77(a_file)) {

#ifdef _WIN32
      builder = GOPAWROOT+"/scripts/DOS/makf77dll.bat";
#else
      builder = GOPAWROOT+"/scripts/sh/makf77dll";
#endif

    } else if(inlib::is_cpp(a_file)) {

#ifdef _WIN32
      builder = GOPAWROOT+"/scripts/DOS/makcdll.bat";
#else
      builder = GOPAWROOT+"/scripts/sh/makcdll";
#endif
    } else if(inlib::is_python(a_file)) {
#ifdef APP_USE_PYTHON
      builder = "internal_python";
#else
      out << "gopaw::function_manager::load_file : gopaw not built with -DAPP_USE_PYTHON." << std::endl;
#endif      
    }

    if(builder.empty()) {
      out << "function_manager::load_file : builder not found for file " << inlib::sout(a_file) << std::endl;
      return false;
    }
  
    if(!load(a_file,builder)) {
      out << "function_manager::load_file : can't load " << inlib::sout(a_file) << std::endl;
      return false;
    }
  
    return true;
  }  
  
  typedef std::vector<imp_value_t> function_args;

  static bool find_f77_functions(const std::string& a_file,
                                 std::vector<std::string>& a_names,
                                 std::vector<function_args>& a_args,
                                 std::ostream& a_out,int a_verbose_level){
    a_names.clear();
    a_args.clear();
    std::vector<std::string> lines;
    std::string _a_file;
    inlib::file_name(a_file,_a_file);
    if(!inlib::file::read(_a_file,lines)) {
      a_out << "gopaw::function_manager::find_f77_functions : can't read file " << inlib::sout(a_file) << "." << std::endl;
      return false;
    }
    unsigned int linen = lines.size();
    bool in_function = false;
    for(unsigned int linei = 0;linei<linen;linei++) {
      std::string line = lines[linei];
      inlib::touppercase(line);
      std::vector<std::string> words;
      inlib::words(line," ",false,words);
      unsigned int index;
      if( inlib::item_index<std::string>(words,"FUNCTION",index)   ||
          inlib::item_index<std::string>(words,"SUBROUTINE",index) ){
        if(in_function) { //Syntax error.
          a_out << "gopaw::function_manager::find_f77_functions :" 
              << " In " << inlib::sout(line) << ","
              << " [FUNCTION,SUBROUTINE] / END mismatch."
              << std::endl;
          a_names.clear();
          a_args.clear();
          return false;
        } 
        // For example : REAL FUNCTION FUNC(I)
        // For example : FUNCTION FUNC(I)
        if((index!=0)&&(index!=1)) { //Syntax error. 
          a_out << "gopaw::function_manager::find_f77_functions :" 
              << " In " << inlib::sout(line) << ","
              << " [FUNCTION,SUBROUTINE] is not the first or second word."
              << std::endl;
          a_names.clear();
          a_args.clear();
          return false;
        }
        if((index+1)>=words.size()) { //Syntax error.
          a_out << "gopaw::function_manager::find_f77_functions :" 
              << " In " << inlib::sout(line) << ","
              << " No space expected between func name and arguments."
              << std::endl;
          a_names.clear();
          a_args.clear();
          return false;
        }
        if(a_verbose_level) {
          a_out << "gopaw::function_manager::find_f77_functions :"
	        << " " << index << " in line " << inlib::sout(line) << "." << std::endl;
        }
        std::string name;
        std::vector<std::string> sargs;
        if(!inlib::name_args(words[index+1],name,sargs)) {
          a_out << "gopaw::function_manager::find_f77_functions :" 
              << " In " << inlib::sout(line) << ","
              << " syntax error in arguments."
              << std::endl;
          a_names.clear();
          a_args.clear();
          return false;
        }
        unsigned int sargn = sargs.size();
        std::vector<imp_value_t> args(sargn);
        for(unsigned int argi=0;argi<sargn;argi++) {
          std::string s = sargs[argi];
          inlib::strip(s);
          if(!inlib::is_variable(s)) {
            a_out << "gopaw::function_manager::find_f77_functions :" 
                  << " In " << inlib::sout(line) << ","
                  << " " << inlib::sout(s)
                  << " has not the syntax of a variable."
                  << std::endl;
            a_names.clear();
            a_args.clear();
            return false;
          }
          imp_value_t& v = args[argi];
          v.set_label(s);
          v.set_itag(1);
          char c = s[0];
          if( (c>='I')&&(c<='N') ) {
            v.set_type(itf_value_t::INT_STAR);
          } else {
            v.set_type(itf_value_t::FLOAT_STAR);
          }
          //WARNING : can't have a DOUBLE_STAR here, else
          //          semantic clash with the VECTOR logic.
        }
        if(a_verbose_level) {
          a_out << "gopaw::function_manager::find_f77_functions :"
	        << " signature : name " << inlib::sout(name) << ", args :" << std::endl;
          inlib_vforcit(imp_value_t,args,it) a_out << (*it).stype() << std::endl;		
        }
        a_names.push_back(name);
        a_args.push_back(args);
        in_function = true;
  
      } else if(inlib::item_index<std::string>(words,"END",index)) {
        if(!in_function) { //Syntax error.
          a_out << "gopaw::function_manager::find_f77_functions :" 
                << " In " << inlib::sout(line) << ","
                << " [FUNCTION,SUBROUTINE] / END mismatch."
                << std::endl;
          a_names.clear();
          a_args.clear();
          return false;
        }
        if(index!=0) { //Syntax error.
          a_out << "gopaw::function_manager::find_f77_functions :" 
                << " In " << inlib::sout(line) << ","
                << " END is not the first word."
                << std::endl;
          a_names.clear();
          a_args.clear();
          return false;
        }
        in_function = false;
      } else if(in_function) {
        // Search argument declaration :
        if( inlib::item_index<std::string>(words,"DIMENSION",index) ||
            inlib::item_index<std::string>(words,"VECTOR",index) ){
          if((index+1)>=words.size()) { //Syntax error.
            a_out << "gopaw::function_manager::find_f77_functions :" 
                  << " In " << inlib::sout(line) << ","
                  << " [DIMENSION,VECTOR] is not the previous last word."
                  << std::endl;
            a_names.clear();
            a_args.clear();
            return false;
          }
          if(index!=0) { //Syntax error.
            a_out << "gopaw::function_manager::find_f77_functions :" 
                  << " In " << inlib::sout(line) << ","
                  << " [DIMENSION,VECTOR] is not the first word."
                  << std::endl;
            a_names.clear();
            a_args.clear();
            return false;
          }
          bool is_vector = (words[index]=="VECTOR");
          std::string s = words[index+1];
          std::vector<std::string> words2;
          inlib::words(s,",",false,words2);
          std::vector<imp_value_t>& last_args = a_args[a_args.size()-1];
          unsigned int wordn2 = words2.size();
          for(unsigned int vari=0;vari<wordn2;vari++) {
            const std::string& VNAME = words2[vari];
            std::string NAME;
            int dim;
            if(!inlib::parse_array(VNAME,NAME,dim)) {
              a_out << "gopaw::function_manager::find_f77_functions :" 
                    << " In " << inlib::sout(line) << ","
                    << " array syntax error in " << inlib::sout(VNAME) << "."
                    << std::endl;
              a_names.clear();
              a_args.clear();
              return false;
            }
            inlib::strip(NAME);
            if(!inlib::is_variable(NAME)) {
              a_out << "gopaw::function_manager::find_f77_functions :" 
                    << " In " << inlib::sout(line) << ","
                    << " " << inlib::sout(NAME) 
                    << " has not the syntax of a variable."
                    << std::endl;
              a_names.clear();
              a_args.clear();
              return false;
            }
            if(is_vector) {
              if(a_verbose_level) {
                a_out << "gopaw::function_manager::find_f77_functions :"
                      << " in function : VECTOR : NAME " << inlib::sout(NAME) << ", dim " << dim << "." << std::endl;
              }
              imp_value_t v;
              v.set_type(itf_value_t::DOUBLE_STAR);
              v.set_label(NAME);
              if(dim!=inlib::not_found()) v.set_itag(dim); //Else 0.Used in pafort.f.
              last_args.push_back(v);
            } else {
              if(a_verbose_level) {
                a_out << "gopaw::function_manager::find_f77_functions :"
                      << " in function : DIMENSION : NAME " << inlib::sout(NAME) << ", dim " << dim << "." << std::endl;
              }
              if(dim==inlib::not_found()) {
                a_out << "gopaw::function_manager::find_f77_functions :" 
                      << " In " << inlib::sout(line) << ","
                      << " variable " << inlib::sout(VNAME) 
                      << " is not an array."
                      << std::endl;
                a_names.clear();
                a_args.clear();
                return false;
              }
  
              //printf("debug : %s %s\n",NAME.c_str(),DIM.c_str());
              bool found = false;
              unsigned int argn = last_args.size();
              for(unsigned int argi=0;argi<argn;argi++) {
                if(last_args[argi].label()==NAME) {
                  imp_value_t& v = last_args[argi];
                  v.set_itag((int)dim);
                  found = true;
                  break;
                }
              }
              if(!found) {
                a_out << "gopaw::function_manager::find_f77_functions :" 
                    << " in " << inlib::sout(line) << ","
                    << " " << inlib::sout(NAME) 
                    << " not found in argument list."
                    << std::endl;
                a_names.clear();
                a_args.clear();
                return false;
              }
            }
          }
        }
      }
    }
  
    return true;
  }

  static bool parse_cpp_header(const std::string& a_header,
                               std::string& a_name,function_args& a_args,unsigned int& a_parn) {
    a_name.clear();
    a_args.clear();
    a_parn = 0;

    std::string line = a_header;

    std::string sfunc;
    unsigned int parn = 0;
  
   {std::string::size_type pos_func = line.find("/*function(");
    if(pos_func!=std::string::npos) {
      // header of the form /*function(<unsigned int>)*/
      std::string::size_type end_pos_func = line.find(")*/");
      if( (end_pos_func==std::string::npos) || (pos_func>=end_pos_func) ) return false;
      sfunc = line.substr(end_pos_func+3,line.size()-(end_pos_func+3));
      std::string sparn = line.substr(pos_func+11,(end_pos_func-(pos_func+11)));
      typedef unsigned int uint_t;
      if(!inlib::to<uint_t>(sparn,parn)) return false; //Syntax error.
    }}
  
   {std::string::size_type pos_func = line.find("/*function*/");
    if(pos_func!=std::string::npos) {
      sfunc = line.substr(pos_func+12,line.size()-(pos_func+12));
    }}
  
    if(!sfunc.size()) return true; //not a header.
  
    std::string head;
    std::vector<std::string> sargs;
    if(!inlib::name_args(sfunc,head,sargs)) return false;
    inlib::strip(head);
  
    // head is of the form <type> <name>.
   {std::vector<std::string> words;
    inlib::words(head," ",false,words);
    if(words.size()!=2) return false;
    std::string name = words[1];
    inlib::strip(name);
    if(!inlib::is_variable(name)) return false;
    a_name = name;}
  
    unsigned int argn = sargs.size();
  
    // Arguments :
    std::vector<imp_value_t> vargs;
    for(unsigned int argi=0;argi<argn;argi++) {
        std::vector<std::string> words;
        inlib::words(sargs[argi]," ",false,words);
        if(words.size()!=2) { //Syntax error
          a_name.clear();
          return false;
        }
        imp_value_t v;
  
        std::string type = words[0];
        std::string s = words[1];
        inlib::strip(s);
        // Look for <atring>[<number>]
       {std::string::size_type lbrace = s.find('[');
        std::string::size_type rbrace = s.find(']');
        if((lbrace==std::string::npos)&&(rbrace==std::string::npos)){
          if(!inlib::is_variable(s)) {
            a_name.clear();
            return false;
          }
          v.set_label(s);
          v.set_itag(0);
	  std::string type_last = type.size()?type.substr(type.size()-1,1):"";
          if(type=="int") {
            v.set_type(itf_value_t::INT);
          } else if(type=="float") {
            v.set_type(itf_value_t::FLOAT);
          } else if(type=="double") {
            v.set_type(itf_value_t::DOUBLE);
	  } else if(type_last=="*") {
	    v.set_type(itf_value_t::VOID_STAR);
          } else { //Type not supported.
            a_name.clear();
            return false;
          }
        } else if( (lbrace!=std::string::npos) &&
                   (rbrace!=std::string::npos) && 
                   (lbrace<rbrace)             ){
          std::string NAME = s.substr(0,lbrace);
          if(!inlib::is_variable(NAME)) {
            a_name.clear();
            return false;
          }
          std::string DIM = s.substr(lbrace+1,rbrace-(lbrace+1));
          unsigned int dim = 0;
          if(DIM.empty()) { //xxx[] syntax
            dim = 0; 
          } else {
            typedef unsigned int uint_t;
            if(!inlib::to<uint_t>(DIM,dim)) { //Syntax error.
              a_name.clear();
              return false;
            }
          }
          v.set_label(NAME);
          v.set_itag(dim);
          if(type=="int") {
            v.set_type(itf_value_t::INT_STAR);
          } else if(type=="float") {
            v.set_type(itf_value_t::FLOAT_STAR);
          } else if(type=="double") { //VECTOR for gopaw.
            v.set_type(itf_value_t::DOUBLE_STAR);
            //dim could be 0 to indicate pafort.f 
            //to search for an existing VECTOR
          } else { //Type not supported.
            a_name.clear();
            return false;
          }
        } else {  //Syntax error.
          a_name.clear();
          return false;
        }}          
        vargs.push_back(v);
    }
    
    a_args = vargs;
    a_parn = parn;
    
    return true;
  }

  static bool find_cpp_functions(const std::string& a_file,
                                 std::vector<std::string>& a_names,
                                 std::vector<function_args>& a_args,
                                 std::vector<unsigned int>& a_parns){
    a_names.clear();
    a_args.clear();
    a_parns.clear();
    std::vector<std::string> lines;
    std::string _a_file;
    inlib::file_name(a_file,_a_file);
    inlib::file::read(_a_file,lines);
    unsigned int linen = lines.size();
    for(unsigned int linei = 0;linei<linen;linei++) {
      std::string name;function_args args;unsigned int parn;
      if(!parse_cpp_header(lines[linei],name,args,parn)) {
        a_names.clear();
        a_args.clear();
        a_parns.clear();
	return false;
      }
      if(name.size()) {
        a_names.push_back(name);
        a_args.push_back(args);
        a_parns.push_back(parn);
      }
    }
    return true;
  }

#ifdef APP_USE_PYTHON
  static bool find_py_functions(std::ostream& a_out,
                                const std::string& a_file,
                                std::vector<std::string>& a_names,
                                std::vector<function_args>& a_args,
                                std::vector<unsigned int>& a_parns,unsigned int a_verbose_level){
    a_names.clear();
    a_args.clear();
    a_parns.clear();
    std::vector<std::string> lines;
    std::string _a_file;
    inlib::file_name(a_file,_a_file);
    inlib::file::read(_a_file,lines);
    unsigned int linen = lines.size();
    for(unsigned int linei = 0;linei<linen;linei++) {
      std::string& line = lines[linei];
      std::string sfunc;
  
      unsigned int parn = 0;
  
     {std::string::size_type pos_func = line.find("def ");
      if(pos_func!=std::string::npos) {
        sfunc = line.substr(pos_func+4,line.size()-(pos_func+4));
      }}
  
      if(!sfunc.size()) continue; //not a header.
      
      if(a_verbose_level) {
        a_out << "gopaw::function_manager::find_py_functions : candidate function header " << inlib::sout(sfunc) << std::endl;
      }

      // look for a "#/*function..." that permits to declare vectors.
     {std::string name;function_args args;unsigned int parn;
      if(!parse_cpp_header(lines[linei],name,args,parn)) {
        a_names.clear();
        a_args.clear();
        a_parns.clear();
	return false;
      }
      if(name.size()) {
        a_names.push_back(name);
        a_args.push_back(args);
        a_parns.push_back(parn);
        continue;
      }}

      // look for a Python header only (args are considered as doubles) :
      std::string head;
      std::vector<std::string> sargs;
      if(!inlib::name_args(sfunc,head,sargs)) {
        if(a_verbose_level) {
          a_out << "gopaw::function_manager::find_py_functions : not a function header." << std::endl;
        }
        a_names.clear();
        a_args.clear();
        a_parns.clear();
        return false;
      }
      inlib::strip(head);
  
     {std::string name = head;
      inlib::strip(name);
      if(!inlib::is_variable(name)) {
        a_names.clear();
        a_args.clear();
        a_parns.clear();
        return false;
      }
      a_names.push_back(name);}
  
      unsigned int argn = sargs.size();
  
      // Arguments :
      std::vector<imp_value_t> vargs;
      for(unsigned int argi=0;argi<argn;argi++) {
        std::string s = sargs[argi];
        inlib::strip(s);
        if(a_verbose_level) {
          a_out << "gopaw::function_manager::find_py_functions : argument " << inlib::sout(s) << std::endl;
        }
        imp_value_t v;
        if(!inlib::is_variable(s)) {
          a_names.clear();
          a_args.clear();
          a_parns.clear();
          return false;
        }
        v.set_label(s);
        v.set_itag(0);
        v.set_type(itf_value_t::DOUBLE); //python has no type.
        vargs.push_back(v);
      } 
      a_args.push_back(vargs);
      a_parns.push_back(parn);
    }
    return true;
  }
#endif

  static bool edit_f77_file(const std::string& a_file,
                            const std::string& a_new_file,
                            const std::vector<std::string>& a_names,
                            const std::vector<function_args>& a_args){
    // Create  modified FORTRAN file :
    //   REAL FUNCTION FUNC(X)
    //   VECTOR A,B(1) 
    // changed to :
    //   REAL FUNCTION FUNC(X,A,B)
    //   REAL A,B(1)
    std::vector<std::string> lines;
    std::string _a_file;
    inlib::file_name(a_file,_a_file);
    if(!inlib::file::read(_a_file,lines)) return false;
  
    FILE* out_file = ::fopen(a_new_file.c_str(),"wb");
    if(!out_file) return false;
  
    unsigned funci = 0;
  
    unsigned int linen = lines.size();
    for(unsigned int linei = 0;linei<linen;linei++) {
      std::string line = lines[linei];
  
      inlib::touppercase(line);
  
      std::vector<std::string> words;
      inlib::words(line," ",false,words);
  
      unsigned int index;
      if( inlib::item_index<std::string>(words,"FUNCTION",index)   ||
          inlib::item_index<std::string>(words,"SUBROUTINE",index) ){
  
        // Assume that the line syntax is correct :
        //    <REAL,INTEGER> FUNCTION <name>(<args>)
        // Add extra arguments (coming from VECTOR) at end
        // of arguments.
  
        std::string new_line;
  
        std::string::size_type lb = line.find('(');
        if(lb==std::string::npos) {
          new_line = lines[linei];
        } else {
          new_line = lines[linei].substr(0,lb);
        }
        new_line += "(";
  
       {const std::vector<imp_value_t>& args = a_args[funci];
        unsigned int argn = args.size();
        for(unsigned int argi=0;argi<argn;argi++) {
          if(argi) new_line += ",";
          new_line += args[argi].label();
        }}
   
        new_line += ")";
  
        ::fprintf(out_file,"%s\n",new_line.c_str());
        funci++;
  
      } else if(inlib::item_index<std::string>(words,"VECTOR",index)) {
  
        if((index+1)>=words.size()) return false;
  
                             //01234567
        std::string new_line = "      REAL*8 ";
  
        std::string s = words[index+1];
        std::vector<std::string> words2;
        inlib::words(s,",",false,words2);
        unsigned int wordn2 = words2.size();
        for(unsigned int vari=0;vari<wordn2;vari++) {
          const std::string& VNAME = words2[vari];
          std::string NAME;
          int dim;
          if(!inlib::parse_array(VNAME,NAME,dim)) return false;
          inlib::strip(NAME);
          if(vari) new_line += ",";
          new_line += NAME;
          new_line += "(*)";
        }
  
        ::fprintf(out_file,"%s\n",new_line.c_str());
  
      } else {
  
        ::fprintf(out_file,"%s\n",lines[linei].c_str());
  
      }
    }
  
    ::fclose(out_file);
    return true;
  }

protected:
  gopaw::ifunction* _find_function(const std::string& a_model){
    std::list<gopaw::ifunction*>::iterator it;
    for(it=fList.begin();it!=fList.end();++it) {
      if(a_model==(*it)->model()) return (*it);
    }
    return 0;
  }

  bool load(const std::string& a_file,const std::string& a_builder){
    std::ostream& out = m_out;
    std::string _a_file;
    inlib::file_name(a_file,_a_file);
    if(!inlib::file::exists(_a_file)) {
      out << "gopaw::function_manager::load : file " << inlib::sout(a_file) << " not found." << std::endl;
      return false;
    }
    if(inlib::is_f77(_a_file)) return load_f77(_a_file,a_builder);  
    if(inlib::is_cpp(_a_file)) return load_cpp(_a_file,a_builder);  
#ifdef APP_USE_PYTHON
    if(inlib::is_python(_a_file)) return load_py(_a_file,a_builder);
#endif    
    return false;
  }
  
  bool set_env(){
    std::string fs = inlib::sep();  
    if(!inlib::putenv("GOPAWROOT",m_res_dir+fs+"gopaw")) return false;
    if(!inlib::putenv("INLIBROOT",m_res_dir+fs+"inlib")) return false;      
    return true;
  }

  bool load_f77(const std::string& a_file,const std::string& a_builder){
    std::ostream& out = m_out;
    std::vector<std::string> funcs;
    std::vector<function_args> args;
    if(!find_f77_functions(a_file,funcs,args,out,m_verbose_level)) {
      out << "gopaw::function_manager::load_f77 : syntax problem in file " << inlib::sout(a_file) << "." << std::endl;
      return false;
    }
    if(!funcs.size()) {
      out << "gopaw::function_manager::load_f77 : file " << inlib::sout(a_file) << " has no functions." << std::endl;
      return false;
    }
  
    std::string new_file = "gopaw_f77_new_"+inlib::nosuffix(a_file)+".f";
  
    if(!edit_f77_file(a_file,new_file,funcs,args)) {
      out << "gopaw::function_manager::load_f77 : can't produce new file " << inlib::sout(new_file)
          << " from file " << inlib::sout(a_file) << "."
          << std::endl;
      return false;
    }
  
    if(m_verbose_level) {
      out << "gopaw::function_manager::load_f77 : functions in file " << inlib::sout(new_file) << std::endl;
      unsigned int funcn = funcs.size();
      for(unsigned int funci=0;funci<funcn;funci++) {
        std::string sargs;
        unsigned int argn = args[funci].size();
        for(unsigned int argi=0;argi<argn;argi++) {
          if(argi) sargs += ",";
          sargs += args[funci][argi].stype();
          sargs += " ";	 
          sargs += args[funci][argi].label();
          sargs += "(";
          inlib::numas(args[funci][argi].itag(),sargs);
          sargs += ")";
        }
        out << "gopaw::function_manager::load_f77 :" 
            << " name : " << inlib::sout(funcs[funci]) 
            << " args : " << inlib::sout(sargs) 
            << std::endl;
      }
    }
  
    std::vector<inlib::plugin::procedure> procs;
    
   {std::string path,name,suffix;
    inlib::path_name_suffix(new_file,path,name,suffix);
    std::string dll = inlib::nosuffix(name);
    if(!get_procs(dll,suffix,"gopaw_f77_wrap_",funcs,args,procs,a_builder,build_f77_dll)) {
      out << "gopaw::function_manager::load_f77 :" 
          << " unable to get some f77 function in " << inlib::sout(dll)
          << std::endl;
      return false;
    }
    if(m_verbose_level) {
      out << "gopaw::function_manager::load_f77 : found f77 functions in " << inlib::sout(dll) << std::endl;
    }}
  
    unsigned int funcn = funcs.size();
    for(unsigned int funci=0;funci<funcn;funci++) {
      add_function(a_file,funcs[funci],(void*)procs[funci],args[funci],0);
    }
  
    return true;
  }

  bool load_cpp(const std::string& a_file,const std::string& a_builder){
    std::ostream& out = m_out;
    std::vector<std::string> funcs;
    std::vector<function_args> args;
    std::vector<unsigned int> parns;
    if(!find_cpp_functions(a_file,funcs,args,parns)) {
      out << "gopaw::function_manager::load_cpp : syntax problem in file " << inlib::sout(a_file) << "." << std::endl;
      return false;
    }
    if(!funcs.size()) {
      out << "gopaw::function_manager::load_cpp : file " << inlib::sout(a_file) << " has no functions." << std::endl;
      return false;
    }

    std::string new_file = "gopaw_cpp_new_"+inlib::nosuffix(a_file)+".c";
   {std::string _a_file;
    inlib::file_name(a_file,_a_file); //handle envs, if any.
    if(!inlib::file::copy_bytes(_a_file,new_file)) {
      out << "gopaw::function_manager::load_cpp : can't produce new file " << inlib::sout(new_file)
          << " from file " << inlib::sout(a_file) << "."
          << std::endl;
      return false;
    }}

    if(m_verbose_level) {
      out << "gopaw::function_manager::load_cpp : functions in file " << inlib::sout(new_file) << std::endl;
      unsigned int funcn = funcs.size();
      for(unsigned int funci=0;funci<funcn;funci++) {
        std::string sargs;
        unsigned int argn = args[funci].size();
        for(unsigned int argi=0;argi<argn;argi++) {
          if(argi) sargs += ",";
          sargs += args[funci][argi].stype();
          sargs += " ";
          sargs += args[funci][argi].label();
          sargs += "(";
          inlib::numas(args[funci][argi].itag(),sargs);
          sargs += ")";
        }
        out << "gopaw::function_manager::load_cpp : name : " << inlib::sout(funcs[funci]) << " args : " << inlib::sout(sargs)
	    << std::endl;
      }
    }
  
    std::vector<inlib::plugin::procedure> procs;

   {std::string path,name,suffix;
    inlib::path_name_suffix(new_file,path,name,suffix);
    std::string dll = inlib::nosuffix(name);
    if(!get_procs(dll,suffix,"gopaw_cpp_wrap_",funcs,args,procs,a_builder,build_C_plugin)) {
      out << "gopaw::function_manager::load_cpp :" 
          << " unable to get some C function in " << inlib::sout(dll)
          << std::endl;
      return false;
    }
    if(m_verbose_level) {
      out << "gopaw::function_manager::load_cpp : found C functions in " << inlib::sout(dll) << std::endl;
    }}
  
    unsigned int funcn = funcs.size();
    for(unsigned int funci=0;funci<funcn;funci++) {
      add_function(a_file,funcs[funci],(void*)procs[funci],args[funci],parns[funci]);    
    }
  
    return true;
  }

#ifdef APP_USE_PYTHON
  static bool import_py(std::ostream& a_out,const std::string& a_file) {
    //if(!::Py_IsInitialized()) {
    //  a_out << "gopaw::function_manager::import_py : Py_IsInitialized() failed." << std::endl;
    //  return false;
    //}
    
    std::string path,name,suffix;
    inlib::path_name_suffix(a_file,path,name,suffix);
    std::string module_name = inlib::nosuffix(name);
    
   {PyObject* py_sys = ::PyImport_ImportModule("sys"); //new ref.
    if(!py_sys) {::PyErr_Print();return false;}
    PyObject* py_sys_path = ::PyObject_GetAttrString(py_sys,"path"); //new ref.
    Py_DECREF(py_sys);
    if(!py_sys_path) {::PyErr_Print();return false;}
    PyObject* py_folder_path = ::PyUnicode_FromString(path.c_str()); //new ref.
    if(!py_folder_path) {Py_DECREF(py_sys_path);::PyErr_Print();return false;}
    ::PyList_Append(py_sys_path,py_folder_path);
    Py_DECREF(py_folder_path);
    Py_DECREF(py_sys_path);}

    PyObject* py_name = ::PyString_FromString(module_name.c_str()); //new ref.
    if(!py_name) {
      a_out << "gopaw::function_manager::import_py : Py_String_FromString(" << inlib::sout(module_name) << ") failed." << std::endl;
      ::PyErr_Print();
      return false;
    }
    //a_out << "debug : 000 : py_name->obj_refcnt " << py_name->ob_refcnt << std::endl;

    PyObject* py_module = ::PyImport_Import(py_name); //new ref.
    Py_DECREF(py_name);
    if(!py_module) {
      a_out << "gopaw::function_manager::import_py : PyImport_Import(" << inlib::sout(module_name) << ") failed." << std::endl;
      ::PyErr_Print();
      Py_DECREF(py_name);
      return false;
    }
    //a_out << "debug : 001 : py_name->obj_refcnt " << py_name->ob_refcnt << std::endl;
    //a_out << "debug : 002 : py_module->obj_refcnt " << py_module->ob_refcnt << std::endl;

    Py_DECREF(py_module);
    
    return true;
  }
 
  static bool py_wrap_func(std::ostream& a_out,const std::string& a_file,const std::string& a_model,
                           const std::vector<inlib::value*>& a_args,inlib::value& a_return) {

    //if(!::Py_IsInitialized()) {
    //  a_out << "gopaw::function_manager::py_wrap_func : Py_IsInitialized() failed." << std::endl;
    //  a_return.set(0.0);
    //  return false;
    //}

    std::string module_name;
    inlib::base_name(a_file,module_name);
    inlib::nosuffix(module_name,module_name);

    PyObject* py_name = ::PyString_FromString(module_name.c_str()); //new ref.
    if(!py_name) {
      a_out << "gopaw::function_manager::py_wrap_func :"
            << " Py_String_FromString(" << inlib::sout(module_name) << ") failed." << std::endl;
      ::PyErr_Print();
      a_return.set(0.0);
      return false;
    }

    PyObject* py_module = ::PyImport_Import(py_name); //new ref.
    Py_DECREF(py_name);
    if(!py_module) {
      a_out << "gopaw::function_manager::py_wrap_func : PyImport_Import(" << inlib::sout(module_name) << ") failed." << std::endl;
      ::PyErr_Print();
      a_return.set(0.0);
      return false;
    }
    //a_out << "debug : 003 : py_module->obj_refcnt " << py_module->ob_refcnt << std::endl;

    PyObject* py_dict = ::PyModule_GetDict(py_module); //borrowed ref.
    if(!py_dict) {
      a_out << "gopaw::function_manager::py_wrap_func : PyModule_GetDict() failed." << std::endl;
      ::PyErr_Print();
      a_return.set(0.0);
      return false;
    }
    
    PyObject* py_func = ::PyDict_GetItemString(py_dict,a_model.c_str()); //borrowed ref.
    if(!py_func) {
      a_out << "gopaw::function_manager::py_wrap_func :"
            << " PyDict_GetItemString(" << inlib::sout(a_model) << ") failed." << std::endl;
      ::PyErr_Print();
      a_return.set(0.0);
      return false;
    }
    if(!::PyCallable_Check(py_func)) {
      a_out << "gopaw::function_manager::py_wrap_func : PyCallable_Check() failed." << std::endl;
      ::PyErr_Print();
      a_return.set(0.0);
      return false;
    }

 // a_out << "gopaw::function_manager::py_wrap_func : args :" << std::endl;
 //{inlib_vforcit(inlib::value*,a_args,it) a_out << " " << (*it)->stype() << std::endl;}

    //mandel.py : //def mandel(XP,YP):         => two args of types  : DOUBLE, DOUBLE.
    //read.py   : //def read(K,RUN,ACT,EACT):  => four args of types : INT, DOUBLE_STAR, DOUBLE_STAR,DOUBLE_STAR.

    //Py_INCREF(Py_None);
    //return Py_None;
	
    size_t argn = a_args.size();
    PyObject* py_args = 0;
    if(!argn) {
      Py_INCREF(Py_None);
      py_args = Py_None;
    } else {
      py_args = ::PyTuple_New(argn); //new ref.
    }
    
    if(!py_args) {
      a_out << "gopaw::function_manager::py_wrap_func : build py_args : can't create a PyTuple." << std::endl;
      ::PyErr_Print();
      a_return.set(0.0);
      return false;
    }

    typedef std::pair<inlib::value*,PyObject*> arg_py_t; //touchy, touchy.
    std::vector<arg_py_t> arg_pys;
    
    for(size_t argi=0;argi<argn;argi++) {
      /*const*/ inlib::value* value = a_args[argi];
      if(value->type()==inlib::value::INT) {
        PyObject* obj = ::PyInt_FromLong(value->get_int()); //new ref
        ::PyTuple_SetItem(py_args,argi,obj);
	//Py_DECREF(obj); //? it crashes.

      } else if(value->type()==inlib::value::DOUBLE) {
        PyObject* obj = ::PyFloat_FromDouble(value->get_double()); //new ref
        ::PyTuple_SetItem(py_args,argi,obj);
	//Py_DECREF(obj); //?
	
      } else if(value->type()==inlib::value::DOUBLE_STAR) {
        double* dstar = value->get_double_star();
	unsigned int sz = value->itag();
	//::printf("debug : 0000 : sz %u\n",sz);
        PyObject* obj = ::PyList_New(sz); //new ref.
        for(unsigned int index=0;index<sz;index++) {
          PyObject* _obj = ::PyFloat_FromDouble(dstar[index]); //new ref
          ::PyList_SetItem(obj,index,_obj);
          //Py_DECREF(_obj);
        }
        ::PyTuple_SetItem(py_args,argi,obj);
        arg_pys.push_back(arg_py_t(value,obj));

      } else {
        a_out << "gopaw::function_manager::py_wrap_func :"
	      << " for arg " << inlib::sout(value->label())
	      << ", arg type " << value->stype() << " not treated."
	      << std::endl;
        ::PyErr_Print();
	Py_DECREF(py_args);
        a_return.set(0.0);
        return false;
      } 
    }

    PyObject* py_result = PyObject_CallObject(py_func,py_args); //new ref.
    if(!py_result) {
      a_out << "gopaw::function_manager::py_wrap_func : PyObject_CallObject() failed." << std::endl;
      ::PyErr_Print();
      Py_DECREF(py_args);
      Py_DECREF(py_module);
      a_return.set(0.0);
      return false;
    }
    
    // restore values in arrays :
   {inlib_vforcit(arg_py_t,arg_pys,it) {
      inlib::value* value = (*it).first;
      double* dstar = value->get_double_star();
      unsigned int sz = value->itag();
      
      PyObject* obj = (*it).second;
      if(!PyList_Check(obj)) {
        a_out << "gopaw::function_manager::py_wrap_func : after exec : arg PyObject not a PyList." << std::endl;
        ::PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_result);
        Py_DECREF(py_module);
        a_return.set(0.0);
        return false;
      }
      Py_ssize_t psz = ::PyList_Size(obj);
      
      if(psz!=Py_ssize_t(sz)) {
        a_out << "gopaw::function_manager::py_wrap_func : after exec : arg PyList :"
	      << " PyList/VECTOR size mismatch. PyList " << psz  << ", VECTOR " << sz << "." << std::endl;
        ::PyErr_Print();
        Py_DECREF(py_args);
        Py_DECREF(py_result);
        Py_DECREF(py_module);
        a_return.set(0.0);
        return false;
      }
      for(unsigned int index=0;index<sz;index++) {
        PyObject* _obj = PyList_GetItem(obj,index); //borrowed ref.
        if(PyFloat_Check(_obj)) {
          dstar[index] = ::PyFloat_AsDouble(_obj);
        } else if(PyInt_Check(_obj)) {
          dstar[index] = double(::PyInt_AsLong(_obj));
        } else if(PyLong_Check(_obj)) {
          dstar[index] = double(::PyLong_AsDouble(_obj));
        } else if(PyString_Check(_obj)) {
	  std::string _s(::PyString_AsString(_obj));
	  double d;
          if(!inlib::to<double>(_s,d)) {
            a_out << "gopaw::function_manager::py_wrap_func : PyString value "
                  << inlib::sout(_s) << " not a double."
                  << std::endl;
            ::PyErr_Print();
            Py_DECREF(py_args);
            Py_DECREF(py_result);
            Py_DECREF(py_module);
            a_return.set(0.0);
            return false;
	  }
          dstar[index] = d;
        } else {
          a_out << "gopaw::function_manager::py_wrap_func :"
                << " PyList elem " << index << " not a PyFloat, PyInt or PyString."
                << " Found " << std::string(_obj->ob_type->tp_name) << "."
                << std::endl;
          ::PyErr_Print();
          Py_DECREF(py_args);
          Py_DECREF(py_result);
          Py_DECREF(py_module);
          a_return.set(0.0);
          return false;
	} 
      }
    }}


    Py_DECREF(py_args);
    
    double dres = ::PyFloat_AsDouble(py_result);
    a_return.set(dres);

    Py_DECREF(py_result);
    Py_DECREF(py_module);
    
    return true;
  }

  bool load_py(const std::string& a_file,const std::string& a_builder){
    std::ostream& out = m_out;
    if(m_verbose_level) {
      out << "gopaw::function_manager::load_py : file " << inlib::sout(a_file) << " ..." << std::endl;
    }
    std::vector<std::string> funcs;
    std::vector<function_args> args;
    std::vector<unsigned int> parns;
    if(!find_py_functions(m_out,a_file,funcs,args,parns,m_verbose_level)) {
      out << "gopaw::function_manager::load_py : syntax problem in file " << inlib::sout(a_file) << "." << std::endl;
      return false;
    }
    if(!funcs.size()) {
      out << "gopaw::function_manager::load_py : file " << inlib::sout(a_file) << " has no functions." << std::endl;
      return false;
    }
  
    if(m_verbose_level) {
      out << "gopaw::function_manager::load_py : functions in file " << inlib::sout(a_file) << std::endl;
      unsigned int funcn = funcs.size();
      for(unsigned int funci=0;funci<funcn;funci++) {
        std::string sargs;
        unsigned int argn = args[funci].size();
        for(unsigned int argi=0;argi<argn;argi++) {
          if(argi) sargs += ",";
          sargs += args[funci][argi].stype();
          sargs += " ";
          sargs += args[funci][argi].label();
          sargs += "(";
          inlib::numas(args[funci][argi].itag(),sargs);
          sargs += ")";
        }
        out << "gopaw::function_manager::load_py : name : " << inlib::sout(funcs[funci]) << " args : " << inlib::sout(sargs)
	    << std::endl;
      }
    }

    if(!import_py(out,a_file)) return false;  //import a_file from C++.

    std::vector<inlib::plugin::procedure> procs;
    // we have the same py_wrap_func for all funcs.
/*
    std::string path,name,suffix;
    inlib::path_name_suffix(new_file,path,name,suffix);
    std::string dll = inlib::nosuffix(name);
    if(!get_procs(dll,suffix,"gopaw_py_wrap_",funcs,args,procs,a_builder,build_C_plugin)) {
      out << "gopaw::function_manager::load_py :" 
          << " unable to get some Python function in " << inlib::sout(dll)
          << std::endl;
      return false;
    }
    if(m_verbose_level) {
      out << "gopaw::function_manager::load_py : found Python function in " << inlib::sout(dll) << std::endl;
    }
*/
   {unsigned int funcn = funcs.size();
    for(unsigned int funci=0;funci<funcn;funci++) {
      procs.push_back((inlib::plugin::procedure)py_wrap_func);
    }}
    
   {unsigned int funcn = funcs.size();
    for(unsigned int funci=0;funci<funcn;funci++) {
      add_function(a_file,funcs[funci],(void*)procs[funci],args[funci],parns[funci]);    
    }}
    
    return true;
  }
#endif


  gopaw::ifunction* add_function(const std::string& a_file,
                                 const std::string& a_model,
                                 void* a_address,const std::vector<imp_value_t>& a_args,unsigned int a_parn){
    if(a_model.empty()) return 0;
    gopaw::ifunction* entry = _find_function(a_model);
    if(entry) return entry;
    entry = new gopaw::plugin_func(m_out,a_file,a_model,a_address,a_args,a_parn);
    fList.push_back(entry);
    return entry;
  }


  typedef bool (*plugin_builder_func)(const std::string&,const std::string&,const std::vector<std::string>&,const std::vector<function_args>&,const std::string&,std::ostream&);

  bool get_procs(const std::string& a_plugin,
                 const std::string& a_suffix,
                 const std::string& a_prefix,
                 const std::vector<std::string>& a_funcs,
                 const std::vector<function_args>& a_args,
                 std::vector<inlib::plugin::procedure>& a_procs,
                 const std::string& a_builder,
                 plugin_builder_func a_build_func){
    a_procs.clear();
    std::ostream& out = m_out;
    inlib::plugin* _plugin = find_plugin(a_plugin);
    if(!_plugin) {
      _plugin = new inlib::plugin(a_plugin,out,m_verbose_level?true:false,true); //true=quiet.
      if(!_plugin->is_opened()) {
        delete _plugin;
        if(!a_build_func(a_plugin,a_suffix,a_funcs,a_args,a_builder,out)) return false;
        _plugin = new inlib::plugin(a_plugin,out,m_verbose_level?true:false);
        if(!_plugin->is_opened()) {
          delete _plugin;
          return false;
        }
      }
      if(m_verbose_level) {
        out << "function_manager::get_procs : load plugin for " << inlib::sout(a_plugin) << " done." << std::endl;
      }
      //execute("Initialize");
      m_plugins.push_back(_plugin);
    }
  
    unsigned int funcn = a_funcs.size();
    for(unsigned int funci=0;funci<funcn;funci++) {
      const std::string& funcName = a_funcs[funci];
      std::string CNAME = a_prefix + funcName;
      inlib::plugin::procedure proc = _plugin->find(CNAME);
      if(proc) {
        a_procs.push_back(proc);
        if(m_verbose_level)
          out << "get_C_function : function " << inlib::sout(funcName) << " found in " << inlib::sout(a_plugin) << std::endl;
      } else {
        if(m_verbose_level)
          out << "get_C_function : function " << inlib::sout(funcName) << " not found in " << inlib::sout(a_plugin) << std::endl;
        a_procs.clear();
        return false;
      }    
    }
  
    return true;
  }

  static bool cxx_type(const imp_value_t& aThis,std::string& a_value ) {
    switch(aThis.type()) {
    case itf_value_t::INT: 
      a_value = "int";
      return true;
    case itf_value_t::DOUBLE: 
      a_value = "double";
      return true;
    case itf_value_t::STRING: 
      a_value = "std::string";
      return true;
    case itf_value_t::BOOL: 
      a_value = "bool";
      return true;
    case itf_value_t::SHORT: 
      a_value = "short";
      return true;
    case itf_value_t::FLOAT: 
      a_value = "float";
      return true;
      //    case itf_value_t::CHAR: 
      //      a_value = "char";
      //      return true;
      //    case itf_value_t::UNSIGNED_CHAR: 
      //      a_value = "unsigned char";
      //      return true;
    case itf_value_t::UNSIGNED_SHORT: 
      a_value = "unsigned short";
      return true;
    case itf_value_t::UNSIGNED_INT: 
      a_value = "unsigned int";
      return true;
    case itf_value_t::VOID_STAR: 
      a_value = "void*";
      return true;
    case itf_value_t::DOUBLE_STAR: 
      a_value = "double*";
      return true;
    case itf_value_t::FLOAT_STAR: 
      a_value = "float*";
      return true;
    case itf_value_t::INT_STAR: 
      a_value = "int*";
      return true;
    case itf_value_t::NONE:
    case itf_value_t::INT64:
    case itf_value_t::UNSIGNED_INT64:
      //case itf_value_t::ARRAY_UNSIGNED_CHAR:
      //case itf_value_t::ARRAY_CHAR:
    case itf_value_t::ARRAY_UNSIGNED_SHORT:
    case itf_value_t::ARRAY_SHORT:
    case itf_value_t::ARRAY_UNSIGNED_INT:
    case itf_value_t::ARRAY_INT:
    case itf_value_t::ARRAY_UNSIGNED_INT64:
    case itf_value_t::ARRAY_INT64:
    case itf_value_t::ARRAY_FLOAT:
    case itf_value_t::ARRAY_DOUBLE:
    case itf_value_t::ARRAY_BOOL:
    case itf_value_t::ARRAY_STRING:
      a_value = "";
      return false;
    }
    return false;
  }

  static bool build_f77_dll(const std::string& a_name,
                            const std::string& a_suffix,
                            const std::vector<std::string>& a_funcs,
                            const std::vector<function_args>& a_args,
                            const std::string& a_builder,
                            std::ostream& a_out) {
    //printf("debug : build_f77_dll : \"%s\"\n",a_name.c_str());

    std::string CNAME = a_name;
    CNAME = std::string("gopaw_f77_wrap_") + CNAME;
    
    // Produce C frontend file :
    std::string fileName = CNAME+".cpp";
    FILE* file = ::fopen(fileName.c_str(),"wb");
    if(!file) {
      a_out << "build_f77_dll : can't create file " << inlib::sout(fileName) << std::endl;
      return false;
    }

    ::fprintf(file,"#include <ostream>\n#include <inlib/value>\nextern \"C\" {\n");

#ifdef _WIN32
    std::string s_stdcall = "__stdcall ";              //space at end.
    std::string s_under = "";
    std::string s_declspec = "_declspec(dllexport) ";  //idem
#else 
    std::string s_stdcall = "";
    std::string s_under = "_";
    std::string s_declspec = "";
#endif

    std::string sh = "    ";
  
    typedef unsigned int uint_t;
  
    unsigned int funcn = a_funcs.size();
    for(unsigned int funci=0;funci<funcn;funci++) {
      std::string funcName = a_funcs[funci];
      unsigned int argn = a_args[funci].size();
  
      std::string sargs;
      std::string sargs2;
      std::string svals;
      svals = "if(a_args.size()!=";
      inlib::numas(argn,svals);
      svals += ") return false;\n";
  
      for(unsigned int argi=0;argi<argn;argi++) {
        if(argi) {
          sargs  += ",";
          sargs2 += ",";
          svals  += "\n";
        }
        const imp_value_t& v = a_args[funci][argi]; //FIXME : use Value.
        std::string scxx;
        if(cxx_type(v,scxx)) {
          //FIXME : put code checking received type.
          sargs += scxx+" ";
          std::string what = scxx;
          inlib::replace(what,"*","_star");
          svals += sh+scxx+" "+v.label()+" = a_args[";
          inlib::numas(argi,svals);
          svals += "]->get_"+what+"();";
        } else {
          a_out << "build_f77_dll :" 
              << " for file " << inlib::sout(a_name) 
              << " can't handle variable type " << inlib::sout(v.stype()) 
              << "."
              << std::endl;
          ::fclose(file);
          ::remove(fileName.c_str());
          return false;
        }
        sargs  += v.label();
        sargs2 += v.label();
      }
  
#ifdef _WIN32
      inlib::touppercase(funcName);
#else
      inlib::tolowercase(funcName);
#endif

      ::fprintf(file,"\
  float %s%s%s(%s);\n\
  %sbool gopaw_f77_wrap_%s(std::ostream& a_out,const std::string& a_file,const std::string& a_model,const std::vector<inlib::value*>& a_args,inlib::value& a_return) {\n\
    %s\n\
    a_return.set(%s%s(%s));\n\
    (void)a_out;(void)a_file;(void)a_model;(void)a_args;\n\
    return true;\n\
  }\n",s_stdcall.c_str(),funcName.c_str(),s_under.c_str(),sargs.c_str(),
       s_declspec.c_str(),a_funcs[funci].c_str(),
       svals.c_str(),
       funcName.c_str(),s_under.c_str(),sargs2.c_str());

    }

    ::fprintf(file,"}\n");

    ::fclose(file);

    std::string _builder = a_builder;
    //inlib::file_name(a_builder,_builder);
    if(!inlib::file::exists(_builder)) {
      a_out << "build_f77_dll : file " << inlib::sout(a_builder) << " not found." << std::endl;
      return false;
    }

    inlib::quote(_builder);
  
    //FIXME : check ret status.
    inlib::std_system(a_out,_builder+" "+a_name+" "+a_suffix+" "+CNAME);
  
    return true;
  }

  static bool build_C_plugin(const std::string& a_name,
                             const std::string& a_suffix,
                             const std::vector<std::string>& a_funcs,
                             const std::vector<function_args>& a_args,
                             const std::string& a_builder,
                             std::ostream& a_out){
    std::string CNAME = a_name;
    CNAME = std::string("gopaw_cpp_wrap_") + CNAME;
    
    // Produce C frontend file :
    std::string fileName = CNAME+".cpp";
    FILE* file = ::fopen(fileName.c_str(),"wb");
    if(!file) {
      a_out << "build_C_plugin :" 
            << " can't create file " << inlib::sout(fileName)
            << std::endl;
      return false;
    }

    ::fprintf(file,"#include <ostream>\n#include <inlib/value>\nextern \"C\" {\n");

#ifdef _WIN32
    std::string s_declspec = "_declspec(dllexport) ";
#else 
    std::string s_declspec = "";
#endif

    std::string sh = "    ";
  
    typedef unsigned int uint_t;
  
    unsigned int funcn = a_funcs.size();
    for(unsigned int funci=0;funci<funcn;funci++) {
      std::string funcName = a_funcs[funci];
      unsigned int argn = a_args[funci].size();
  
      std::string sargs;
      std::string sargs2;
      std::string svals;
      svals = "if(a_args.size()!=";
      inlib::numas(argn,svals);
      svals += ") return false;\n";
  
      for(unsigned int argi=0;argi<argn;argi++) {
        if(argi) {
          sargs  += ",";
          sargs2 += ",";
          svals  += "\n";
        }
        const imp_value_t& v = a_args[funci][argi]; //FIXME : use Value.
        std::string scxx;
        if(cxx_type(v,scxx)) {
          //FIXME : put code checking received type.
          sargs += scxx+" ";
          std::string what = scxx;
          inlib::replace(what,"*","_star");
          svals += sh+scxx+" "+v.label()+" = a_args[";
	  inlib::numas(argi,svals);
          svals += "]->get_"+what+"();";
        } else {
          a_out << "build_c_dll : for file " << inlib::sout(a_name) 
                << " can't handle variable type " << inlib::sout(v.stype()) 
                << "."
                << std::endl;
          ::fclose(file);
          ::remove(fileName.c_str());
          return false;
        }
        sargs  += v.label();
        sargs2 += v.label();
      }
  
      ::fprintf(file,"\
  double %s(%s);\n\
  %sbool gopaw_cpp_wrap_%s(std::ostream& a_out,const std::string& a_file,const std::string& a_model,const std::vector<inlib::value*>& a_args,inlib::value& a_return) {\n\
    %s\n\
    a_return.set(%s(%s));\n\
    (void)a_out;(void)a_file;(void)a_model;(void)a_args;\n\
    return true;\n\
  }\n",funcName.c_str(),sargs.c_str(),
       s_declspec.c_str(),
       a_funcs[funci].c_str(),
       svals.c_str(),
       funcName.c_str(),sargs2.c_str());

    }
    
    ::fprintf(file,"}\n");

    ::fclose(file);

    std::string _builder = a_builder;
    //inlib::file_name(abuilder,_builder);
    if(!inlib::file::exists(_builder)) {
      a_out << "build_c_dll : file " << inlib::sout(a_builder) << " not found." << std::endl;
      return false;
    }
  
    inlib::quote(_builder);
  
    //FIXME : check ret status.
    inlib::std_system(a_out,_builder+" "+a_name+" "+a_suffix+" "+CNAME);
  
    return true;
  }

  inlib::plugin* find_plugin(const std::string& a_name) {
    inlib_vforcit(inlib::plugin*,m_plugins,it) {
      if((*it)->file_name()==a_name) return *it;
    }
    return 0;
  }
protected:
  std::ostream& m_out;
  std::string m_res_dir;
  unsigned int m_verbose_level;
  std::list<gopaw::ifunction*> fList;
  std::vector<inlib::plugin*> m_plugins;
};

}

#endif




